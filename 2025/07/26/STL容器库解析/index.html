<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>第三篇文章 | Hexo</title><meta name="author" content="will"><meta name="copyright" content="will"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="第一章 STL标准模板库标准模板库，即Standard Template Library，简称STL，是一个具有工业强度的，高效的C++程序库。它被容纳于C++标准库中，是ANSI&#x2F;ISO C++标准中最新的也是极具革命性的一部分。该库包含了诸多在计算机科学领域里所常用的基本数据结构和基本算法。为广大C++程序员们提供了一个可扩展的应用框架，高度体现了软件的可复用性。 与之前学到的编程思">
<meta property="og:type" content="article">
<meta property="og:title" content="第三篇文章">
<meta property="og:url" content="https://willcool-cyber.github.io/2025/07/26/STL%E5%AE%B9%E5%99%A8%E5%BA%93%E8%A7%A3%E6%9E%90/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="第一章 STL标准模板库标准模板库，即Standard Template Library，简称STL，是一个具有工业强度的，高效的C++程序库。它被容纳于C++标准库中，是ANSI&#x2F;ISO C++标准中最新的也是极具革命性的一部分。该库包含了诸多在计算机科学领域里所常用的基本数据结构和基本算法。为广大C++程序员们提供了一个可扩展的应用框架，高度体现了软件的可复用性。 与之前学到的编程思">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://willcool-cyber.github.io/img/butterfly-icon.png">
<meta property="article:published_time" content="2025-07-26T06:22:45.000Z">
<meta property="article:modified_time" content="2025-07-26T06:38:55.572Z">
<meta property="article:author" content="will">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://willcool-cyber.github.io/img/butterfly-icon.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "第三篇文章",
  "url": "https://willcool-cyber.github.io/2025/07/26/STL%E5%AE%B9%E5%99%A8%E5%BA%93%E8%A7%A3%E6%9E%90/",
  "image": "https://willcool-cyber.github.io/img/butterfly-icon.png",
  "datePublished": "2025-07-26T06:22:45.000Z",
  "dateModified": "2025-07-26T06:38:55.572Z",
  "author": [
    {
      "@type": "Person",
      "name": "will",
      "url": "https://willcool-cyber.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/will-blog.github.io/img/favicon.png"><link rel="canonical" href="https://willcool-cyber.github.io/2025/07/26/STL%E5%AE%B9%E5%99%A8%E5%BA%93%E8%A7%A3%E6%9E%90/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/will-blog.github.io/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/will-blog.github.io/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '第三篇文章',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/will-blog.github.io/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/will-blog.github.io/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/will-blog.github.io/archives/"><div class="headline">Articles</div><div class="length-num">4</div></a><a href="/will-blog.github.io/tags/"><div class="headline">Tags</div><div class="length-num">3</div></a><a href="/will-blog.github.io/categories/"><div class="headline">Categories</div><div class="length-num">6</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/will-blog.github.io/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/will-blog.github.io/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/will-blog.github.io/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/will-blog.github.io/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/will-blog.github.io/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/will-blog.github.io/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/willcool-cyber-backgroud.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/will-blog.github.io/"><span class="site-name">Hexo</span></a><a class="nav-page-title" href="/will-blog.github.io/"><span class="site-name">第三篇文章</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/will-blog.github.io/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/will-blog.github.io/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/will-blog.github.io/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/will-blog.github.io/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/will-blog.github.io/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/will-blog.github.io/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">第三篇文章</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2025-07-26T06:22:45.000Z" title="Created 2025-07-26 14:22:45">2025-07-26</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2025-07-26T06:38:55.572Z" title="Updated 2025-07-26 14:38:55">2025-07-26</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/will-blog.github.io/categories/STL%E6%A0%87%E5%87%86%E6%A8%A1%E7%89%88%E5%BA%93/">STL标准模版库</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/will-blog.github.io/categories/STL%E6%A0%87%E5%87%86%E6%A8%A1%E7%89%88%E5%BA%93/%E5%AE%B9%E5%99%A8/">容器</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="第一章-STL标准模板库"><a href="#第一章-STL标准模板库" class="headerlink" title="第一章 STL标准模板库"></a>第一章 STL标准模板库</h1><p>标准模板库，即Standard Template Library，简称STL，是一个具有工业强度的，高效的C++程序库。它被容纳于C++标准库中，是ANSI&#x2F;ISO C++标准中最新的也是极具革命性的一部分。该库包含了诸多在计算机科学领域里所常用的基本数据结构和基本算法。为广大C++程序员们提供了一个可扩展的应用框架，高度体现了软件的可复用性。</p>
<p>与之前学到的编程思想面向对象编程不一样，STL采用的是一种新的编程模式：泛型编程。它允许程序员编写通用的代码，即可适用于不同的数据类型，而不必为每种类型<br>编写不同的代码。这种编程方法的基本思想是将数据类型抽象化，使用泛型来表示数据类型，并在编写代码时使用泛型来代替具体的数据类型。本章重点在于介绍泛型编程的思想和本质，介绍一些常用的方法。</p>
<h2 id="STL六大组件"><a href="#STL六大组件" class="headerlink" title="STL六大组件"></a>STL六大组件</h2><p>1、容器：就是用来存储数据的，也就是数据结构。<strong>（重要）</strong></p>
<ul>
<li>序列式容器   vector、list、deque等</li>
<li>关联式容器  set、map等</li>
<li>无序关联式容器  unordered_set、unordered_map等</li>
</ul>
<p>2、迭代器：就是为了访问容器中的元素，可以将其看成是一种指针，称为泛型指针。</p>
<p>3、算法：就是一些普通函数，可以操作容器中的元素。</p>
<p>4、适配器：起到适配的作用。</p>
<ul>
<li>容器适配器  stack、queue、priority_queue</li>
<li>迭代器的适配器</li>
<li>函数适配器   bind、bind1st、bind2nd</li>
</ul>
<p>5、函数对象：做定制化的操作</p>
<p>6、空间配置器：管理内存的（讲解使用 + 原理 + 源码）</p>
<p>数据结构 + 算法 &#x3D; 程序</p>
<h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><h3 id="序列式容器"><a href="#序列式容器" class="headerlink" title="序列式容器"></a>序列式容器</h3><p>序列式容器包括：静态数组array、动态数组vector、双端队列deque、单链表forward_list、双链表list。这五个容器中，我们重点了解三个vector、deque、list的使用，包括：初始化、遍历以及一些基本操作。另外，list还有一些特别的操作，也需要进行了解。</p>
<p>在之后的工作中，这些容器都是很常用的工具。在面试中，对容器的底层原理也可能会有一定的考察。</p>
<h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4><img src="./image-20241114210911152.png" alt="image-20241114210911152" style="zoom:67%;" />



<img src="./image-20240805165600451.png" alt="image-20240805165600451" style="zoom: 80%;" />



<h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><img src="./image-20240805165620662.png" alt="image-20240805165620662" style="zoom:80%;" />

<p><span style=color:red;background:yellow><strong>总结：</strong></span>三种序列式容器vector、deque、list都具备五种初始化的方式，包括：无参、count个value、迭代器范围、拷贝或者移动、大括号范围&#x3D;&#x3D;</p>
<h5 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h5><img src="./image-20240805165708937.png" alt="image-20240805165708937" style="zoom:80%;" />

<img src="./image-20240805165730578.png" alt="image-20240805165730578" style="zoom:80%;" /> 

<p><span style=color:red;background:yellow><strong>总结：</strong></span>三种序列式容器vector、deque、list都支持使用迭代器以及增强for循环方式进行遍历。</p>
<p>但是因为list不支持下标，所以list不能使用下标进行遍历；vector与deque支持下标，可以使用下标进行遍历。</p>
<p><img src="/will-blog.github.io/./image-20240805172036582.png" alt="image-20240805172036582"></p>
<h5 id="在尾部进行插入与删除"><a href="#在尾部进行插入与删除" class="headerlink" title="在尾部进行插入与删除"></a>在尾部进行插入与删除</h5><img src="./image-20240805173950293.png" alt="image-20240805173950293" style="zoom: 80%;" />

<p><span style=color:red;background:yellow><strong>总结：</strong></span>三种序列式容器vector、deque、list都支持在尾部进行插入与删除&#x3D;&#x3D;</p>
<h5 id="在头部进行插入与删除"><a href="#在头部进行插入与删除" class="headerlink" title="在头部进行插入与删除"></a>在头部进行插入与删除</h5><img src="./image-20240806094947791.png" alt="image-20240806094947791" style="zoom:80%;" />

<p><span style=color:red;background:yellow><strong>总结：</strong></span>deque与list支持在头部进行插入与删除，但是vector不支持。</p>
<h5 id="模型理解"><a href="#模型理解" class="headerlink" title="模型理解"></a>模型理解</h5><p><strong>vector</strong></p>
<img src="./image-20250314113757563.png" alt="image-20250314113757563" style="zoom: 67%;" />

<p>vector头部是固定的，不能进行插入与删除，只提供了在尾部进行插入与删除的操作，所以如果真的要在头部插入或者删除，那么其他的元素会发生移动，这样操作就比较复杂。（时间复杂度O(N)）</p>
<p><strong>deque</strong></p>
<img src="./image-20250314113918079.png" alt="image-20250314113918079" style="zoom:67%;" />

<p>从应用层面上，deque所实现的效果是双端队列，自然可以支持头部插入删除与尾部插入删除。</p>
<p><strong>list</strong></p>
<img src="./image-20250314114024724.png" alt="image-20250314114024724" style="zoom:67%;" />

<p>list实现的是双向链表。</p>
<h5 id="源码阅读"><a href="#源码阅读" class="headerlink" title="源码阅读*"></a>源码阅读*</h5><p>想要对这几种容器有更清晰的认知，还可以结合源码来进行理解</p>
<p><strong>vector的源码（了解）</strong></p>
<blockquote>
<p>继承图</p>
<img src="./image-20241114211419722.png" alt="image-20241114211419722" style="zoom:80%;" />



<p>源码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>, <span class="keyword">class</span> <span class="title class_">_Alloc</span> = __STL_DEFAULT_ALLOCATOR(_Tp) &gt;</span><br><span class="line"><span class="keyword">class</span> vector </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">typedef</span> _Tp value_type;</span><br><span class="line"><span class="keyword">typedef</span> value_type* pointer;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">const</span> value_type* const_pointer;</span><br><span class="line"><span class="keyword">typedef</span> value_type* iterator;   <span class="comment">//typedef _Tp* iterator;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">const</span> value_type* const_iterator;</span><br><span class="line"><span class="keyword">typedef</span> value_type&amp; reference;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">const</span> value_type&amp; const_reference;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">size_t</span> size_type;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">ptrdiff_t</span> difference_type;   </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//iterator相当于vector的内部类</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it;</span><br></pre></td></tr></table></figure>

<p>除了vector的数据成员，还可以看到一些成员函数的实现，比如push_back有可能发生的动态扩容（2倍扩容的机制就写在源码中）</p>
</blockquote>
<blockquote>
<p>**思考：**获取vector的第一个元素的首地址，应该怎么做</p>
<img src="./image-20240806111634713.png" alt="image-20240806111634713" style="zoom: 80%;" />

<img src="./image-20250314144207535.png" alt="image-20250314144207535" style="zoom:67%;" />

<p>vector中at与operator[]都具备随机访问的含义，但是operator[]会有越界的风险，也就是不安全，但是at具备范围限制，更加安全一些。</p>
<img src="./image-20250314144256583.png" alt="image-20250314144256583" style="zoom:67%;" /></blockquote>
<p><strong>deque的源码（了解）</strong></p>
<p>deque的实现原理比vector复杂得多</p>
<blockquote>
<p>继承图</p>
<img src="./image-20240806112912866.png" alt="image-20240806112912866" style="zoom:80%;" /></blockquote>
<blockquote>
<p><span style=color:red;background:yellow><strong>原理</strong></span></p>
<p>deque是由多个片段组成的，片段内部是连续的，但是片段之间不连续的，分散的，多个片段被一个称为中控器的结构控制（也称为map，但跟std::map不是一回事）</p>
<p>所以说deque是<font color=red><strong>在物理上是不连续的，但是逻辑上是连续的</strong></font>。</p>
<p>初始化deque时，根据元素的个数分配一些缓冲区片段</p>
<p>在缓冲区片段中存放实际的元素，这里以int型元素为例。通常情况下，在初始化时第一个元素会被放置在第一个缓冲区中相对靠前的位置（而非第一个缓冲区的首地址，这样方便在头部添加元素）。</p>
<p>前后相邻的两个元素在逻辑上是连续的，但是物理层面上可能并不是连续的。</p>
<p>同时还会生成一个数组中控器（map），存放每个缓冲区片段的首地址。（注意map中的元素是int*，而不是严格意义的数组指针，这一点从源码中可以进行理解）</p>
<p>通常情况下，第一个缓冲区片段的首地址被放在中控器map的居中位置。</p>
<p>deque初始化完成后，进行添加元素的操作：</p>
<p><strong>如果在尾部添加元素value</strong></p>
<p>找到最后一个存放着元素的缓冲区片段，在其中最后一个元素的后面添加元素value。</p>
<p>如果此时最后的缓冲区片段是满的，那么就再申请一个新的缓冲区片段，将要添加的元素value存放在新片段的首个位置。同时中控器也加上一个元素（新片段的首地址），让中控器与新片段联系起来。</p>
<p>如果此时中控器已经满了，还要添加内容，那么开辟新的更大的空间作为中控器，将原本中控器中记录的地址值复制到新的中控器，并将最后一个缓冲区片段的首地址加入。</p>
<p><strong>如果是在deque的头部添加元素value</strong></p>
<p>找到已经存储的第一个元素的位置，在它的前面存放新元素value。</p>
<p>经过若干次头部添加元素之后，如果第一个缓冲区片段满了，还要继续在头部添加元素，则新开辟一个缓冲区片段（作为第一个片段），将value存在这个片段中的最后一个位置。同时在中控器的相应位置存放新的缓冲片段的首地址。</p>
<p>如果一直往deque头部添加元素，中控器的前半部分已经满了，后半部分还没满，就将中控器中记录的地址全都后移，将这个第一个缓冲区的首地址存入中控器的第一个位置。如果中控器全都满了，那就再开辟新的更大的空间作为中控器。</p>
<img src="./image-20250315160520768.png" alt="image-20250315160520768" style="zoom:67%;" />

</blockquote>
<p>—— 每个缓冲区片段的大小是多大？</p>
<blockquote>
<img src="./image-20250314162540413.png" alt="image-20250314162540413" style="zoom:67%;" />

<p>如果deque存放的元素类型的大小小于 512 字节。每个缓冲区片段的大小为 512 字节，512 除以元素类型的大小，就可以得到每个缓冲区片段能够存放的元素数量。<br>例如元素类型是 int，在 64 位系统中，sizeof(int)&#x3D; 4 字节。<strong>那么 deque_buf_size(4) 的结果就是 512 &#x2F; 4 &#x3D; 128，即每个缓冲区片段可以存放 128 个 int 类型的元素。</strong><br>这种设计的好处是，对于较小的元素类型，每个缓冲区可以存放较多的元素，减少了缓冲区的数量，从而降低了中控器（用于管理缓冲区的数组）的管理开销。</p>
<p>如果元素类型大小大于等于 512 字节，函数返回 1。这表示每个缓冲区片段只存放一个元素。<br>比如自定义类型A的对象作为deque的元素，单个元素的大小超过了 512 字节，那么 __deque_buf_size(sizeof(A)) 的结果就是 1，每个缓冲区片段只会存放一个 A类型的元素。</p>
</blockquote>
<p>—— deque的迭代器底层是和vector一样吗？</p>
<blockquote>
<p>deque的迭代器比vector的迭代器复杂得多，<code>vector&lt;T&gt;</code>的迭代器实际是对T*的包装，但deque的迭代器实际应该视为对象，数据成员包含四个指针，并且进行了一系列的运算符重载，使得迭代器能够像指针一样被使用。</p>
<img src="./image-20250315161915597.png" alt="image-20250315161915597" style="zoom:67%;" />

<img src="./image-20250315161952642.png" alt="image-20250315161952642" style="zoom:67%;" /></blockquote>
<h5 id="insert操作（重要）"><a href="#insert操作（重要）" class="headerlink" title="insert操作（重要）"></a>insert操作（重要）</h5><p>之前的push_back和push_front尽管可以插入元素，但是插入的位置都比较固定。</p>
<p>实际上三种序列式容器都允许在任意位置插入元素，使用insert函数即可，它们都具备以下四种插入的功能。</p>
<p><img src="/will-blog.github.io/./image-20240806144651816.png" alt="image-20240806144651816"></p>
<blockquote>
<p>以list为例，双向链表由于其底层结构的原因，插入是非常方便的。</p>
<img src="./image-20241203105613687.png" alt="image-20241203105613687" style="zoom:67%;" /></blockquote>
<p>从参考文档出发可知三种序列式容器都有这样的插入方式，但insert过程中的细节却值得注意。</p>
<blockquote>
<p>对于list</p>
<img src="./image-20241203112930981.png" alt="image-20241203112930981"  />

</blockquote>
<blockquote>
<p>如果把list换成deque，情况会有所不同</p>
<img src="./image-20241203151641204.png" alt="image-20241203151641204" style="zoom:80%;" />



<p>在利用迭代器遍历容器元素并做出处理时，往往需要更新迭代器</p>
<img src="./image-20241203152546132.png" alt="image-20241203152546132" style="zoom: 80%;" />

<p><strong>—— list进行insert操作时，同样可以使用这样的方式更新迭代器。可自行试验，查看效果。</strong></p>
</blockquote>
<p>对于vector，insert操作执行过程中还存在着更大的隐患，可能导致<span style=color:red;background:yellow><strong>迭代器失效</strong></span></p>
<img src="./image-20241203162022141.png" alt="image-20241203162022141" style="zoom: 80%;" />



<p>为什么会发生这样的情况呢？</p>
<p>当vector使用insert进行插入时，可能会发生动态扩容。比如上述的nums是一个“存满”状态的vector，此时size和capacity的结果是一样的。增加新的元素会进行扩容。</p>
<p>扩容的过程中会申请一块新的空间，然后将老的空间上的元素拷贝到新的空间来，然后会清理老的空间、这时如果还继续使用原本的迭代器，对应的也就是老的空间的地址，会出现问题，因为此时迭代器已经失效了。</p>
<p><span style=color:red;background:yellow><strong>解决方案：每次在使用迭代器进行insert操作时，更新迭代器（重新置位）</strong></span></p>
<img src="./image-20241203175553874.png" alt="image-20241203175553874" style="zoom:67%;" />



<p><span style=color:red;background:yellow><strong>补充</strong></span></p>
<p>之前在学习vector的push_back操作时，我们了解了2倍扩容机制。而insert导致的扩容，规则更复杂一些。</p>
<p><strong>vector的insert扩容（了解）</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">nums.<span class="built_in">size</span>() = m</span><br><span class="line">nums.<span class="built_in">capacity</span>() = n;</span><br><span class="line"><span class="comment">//要插入的元素的个数为t</span></span><br><span class="line"><span class="comment">//(1) t &lt; n - m       不会扩容</span></span><br><span class="line"><span class="comment">//(2) n - m &lt; t &lt; m   按照2*size()进行扩容</span></span><br><span class="line"><span class="comment">//(3) n - m &lt; t, m &lt; t &lt; n 按照t + m进行扩容</span></span><br><span class="line"><span class="comment">//(4) t &gt; n  按照t + m进行扩容</span></span><br></pre></td></tr></table></figure>



<img src="./image-20250316102038151.png" alt="image-20250316102038151" style="zoom:67%;" />

<img src="./image-20250316102006686.png" alt="image-20250316102006686" style="zoom:67%;" />





<h5 id="erase操作-重要"><a href="#erase操作-重要" class="headerlink" title="erase操作(重要)"></a>erase操作(重要)</h5><p>三种序列式容器都可以进行erase操作，用来删除容器中的单个元素或多个元素</p>
<img src="./image-20240806160154610.png" alt="image-20240806160154610" style="zoom:67%;" />



<blockquote>
<p>list的erase操作</p>
<p>由于list的原理，list中的元素无论是插入还是删除都非常的方便。erase后迭代器it仍然指向原本的地址（实际已经不属于list元素的空间），想要继续正常使用it，需要进行迭代器更新。erase函数的返回值为被删除元素后一位元素对应的迭代器。</p>
<p><img src="/will-blog.github.io/./image-20241202175257615.png" alt="image-20241202175257615"></p>
</blockquote>
<blockquote>
<p>deque的erase操作</p>
<p>deque的erase操作后，迭代器it仍然指向原本的位置。但是原本的位置上存放的是什么，同样需要取决于删除的元素属于前半段还是后半段。</p>
<img src="./image-20241203093724218.png" alt="image-20241203093724218" style="zoom:67%;" />



<p>如果想要一个明确的效果，以便erase之后继续正常使用it这个迭代器，那么同样建议进行迭代器更新</p>
<img src="./image-20241203093928234.png" alt="image-20241203093928234" style="zoom:67%;" /></blockquote>
<p>如果将上述例子中的容器换成vector，似乎不会出现问题。</p>
<p>删除掉一个元素后，如果不更新迭代器，后面的元素往前移，迭代器仍指向原本的位置，对应的就是被删除的元素后一位的元素；</p>
<p>如果更新迭代器，迭代器指向也能够确保是后一位的元素，效果一样。</p>
<blockquote>
<p>但在删除连续重复元素时，vector的erase操作也可能导致迭代器失效问题。</p>
<p>如下，我们在使用vector时很可能写出这样的代码，但结果并没有实现想要的效果：</p>
<p><img src="/will-blog.github.io/./image-20241204110148074.png" alt="image-20241204110148074"></p>
<p>此时通过it &#x3D; nums.erase(it)这样简单更新迭代器并不能解决问题（效果一样）。问题的根本在于，无论是对于该删除的元素还是不该删除的元素，迭代器的偏移采取的是统一的方式。</p>
<p><img src="/will-blog.github.io/./image-20241204112619883.png" alt="image-20241204112619883"></p>
<p>因为在vector中元素是连续的，如果删掉某个元素，后面的元素前移，如果此时迭代器依然往后移动，有可能漏掉一些元素。</p>
<p>解决方式：在删除元素时，就不移动迭代器，从逻辑的角度上来说，对应的元素已经变成了被删元素的下一位。</p>
</blockquote>
<blockquote>
<p>—— 试一试对list完成上述操作，看看会有什么结果？</p>
<p>list进行erase时，还需要更新迭代器</p>
<p><img src="/will-blog.github.io/./image-20241204115650449.png" alt="image-20241204115650449"></p>
</blockquote>
<h5 id="元素的清空"><a href="#元素的清空" class="headerlink" title="元素的清空"></a>元素的清空</h5><p><img src="/will-blog.github.io/./image-20240806162826639.png" alt="image-20240806162826639"></p>
<p><img src="/will-blog.github.io/./image-20240806162838101.png" alt="image-20240806162838101"></p>
<p><img src="/will-blog.github.io/./image-20240806162848551.png" alt="image-20240806162848551"></p>
<p><span style=color:red;background:yellow><strong>总结</strong></span>：</p>
<p>三种序列式容器vector、deque、list都有clear清空元素、以及获取元素个数的函数size；</p>
<p>对于vector与deque，还有回收多余空间的函数shrink_to_fit；</p>
<p>对于vector还有记录容量大小的函数capacity</p>
<h5 id="其他成员函数"><a href="#其他成员函数" class="headerlink" title="其他成员函数"></a>其他成员函数</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//三种序列式容器都具备交换的函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">( list&amp; other )</span></span>;<span class="comment">//此处的list可以改为vector或者deque</span></span><br><span class="line"><span class="comment">//vector与vector交换，deque与deque交换，list与list交换</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//三种序列式容器都具备改变元素个数的函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">resize</span><span class="params">( size_type count, T value = T() )</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">resize</span><span class="params">( size_type count )</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">resize</span><span class="params">( size_type count, <span class="type">const</span> value_type&amp; value )</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="comment">//获取容器的第一个元素与最后一个元素(三种1.STL标准模板库都有)</span></span></span><br><span class="line"><span class="function">reference <span class="title">front</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">const_reference <span class="title">front</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="function">reference <span class="title">back</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">const_reference <span class="title">back</span><span class="params">()</span> <span class="type">const</span></span>;    </span><br></pre></td></tr></table></figure>





<h5 id="emplace-back函数"><a href="#emplace-back函数" class="headerlink" title="emplace_back函数"></a>emplace_back函数</h5><p>这三种序列式容器还有两个值得关注的函数：emplace和emplace_back</p>
<p>emplace与insert对比，前者是直接在指定位置构造对象，后者是将一个已存在的对象复制并插入到容器中指定位置。</p>
<p>emplace_back与push_back对比， 前者是直接在容器尾部构造对象，后者是将一个已存在的对象复制并插入到容器末尾。</p>
<p><img src="/will-blog.github.io/./image-20250317095728675.png" alt="image-20250317095728675"></p>
<blockquote>
<p>查看emplace_back的效果</p>
<p><img src="/will-blog.github.io/./image-20240806164845608.png" alt="image-20240806164845608"></p>
<p>同理可以查看emplace的效果</p>
<img src="./image-20250317104810864.png" alt="image-20250317104810864" style="zoom:67%;" /></blockquote>
<blockquote>
<p>尝试分析下面这段代码的过程</p>
<img src="./image-20250317110158508.png" alt="image-20250317110158508" style="zoom:67%;" />

<p>比较难理解的是最后执行emplace操作时发生一次拷贝，其原理是：</p>
<p>当需要在中间插入元素时（无论是insert还是emplace），标准库会采用一种 “块移动” 的策略。它会先把插入位置之后的所有元素视为一个整体，然后将这个整体一次性向后移动一个位置，而不是逐个元素进行拷贝。在这个过程中，可能只会触发一次拷贝构造，用于将最后一个元素拷贝到新的位置，其他元素则是通过内存移动来完成位置调整。</p>
</blockquote>
<p>接着请思考一下，上面的代码如果在emplace之前没有进行insert操作，又会是怎样的结果呢？</p>
<p>对于这些常用操作，想要更加熟悉，需要多多动手验证，才能了解规则和实现效果。</p>
<h4 id="list的特殊操作（重要）"><a href="#list的特殊操作（重要）" class="headerlink" title="list的特殊操作（重要）"></a>list的特殊操作（重要）</h4><p>list还具有一些vector与deque没有的函数。</p>
<p>注意，这里说的特殊操作也是属于list的成员函数，在使用时仍然是成员函数的使用方式。</p>
<h5 id="sort函数"><a href="#sort函数" class="headerlink" title="sort函数"></a>sort函数</h5><p>将list中的元素排序</p>
<img src="./image-20241205154048844.png" alt="image-20241205154048844" style="zoom:67%;" />

<p>简单示例：</p>
<img src="./image-20241205154657832.png" alt="image-20241205154657832" style="zoom:67%;" />

<p>如果使用无参版本的sort函数，则list中的元素默认以升序排列。</p>
<blockquote>
<p>第二个版本的sort函数有一个参数，参数为Compare类型的对象。关于Compare，第一次见到应该是在set类模板声明中</p>
<img src="./image-20241206162659730.png" alt="image-20241206162659730" style="zoom:67%;" />

<p>之前在简单使用set时我们知道元素会默认按照升序排序，这里就是使用了<code>std::less&lt;key&gt;</code>的效果。做个测试：</p>
<img src="./image-20241206162926925.png" alt="image-20241206162926925" style="zoom:67%;" />

<p>效果和无参的sort版本是一样的，同样采用升序排序。</p>
</blockquote>
<p>这里std::less实际上与之前unique_ptr的默认删除器是很相似的。</p>
<img src="./image-20241206163620509.png" alt="image-20241206163620509" style="zoom:67%;" />



<p>通过cpp参考文档能够了解到std::less进行了函数调用运算符的重载，在operator()函数中接受两个参数，代表两个元素，在函数定义中对两个元素进行了比较。</p>
<img src="./image-20241206164121319.png" alt="image-20241206164121319" style="zoom:67%;" />



<p>—— 如果想要按照降序排列，对应位置可以换成std::greater</p>
<img src="./image-20241209102349777.png" alt="image-20241209102349777" style="zoom:67%;" />



<p>当然，针对需要排序的各种元素类型，可能需要更灵活的Compare，那么我们可以像定制化删除器一样定制化Compare</p>
<img src="./image-20241209105703516.png" alt="image-20241209105703516" style="zoom:67%;" />

<p>会发现自定义的Compare对象被当成函数调用了很多次，可以简单阅读list的sort函数源码</p>
<p>其底层实现实际是一种基于归并排序的做法</p>
<h5 id="reverse函数"><a href="#reverse函数" class="headerlink" title="reverse函数"></a>reverse函数</h5><p>将list的所有元素顺序反转</p>
<img src="./image-20241209114609938.png" alt="image-20241209114609938" style="zoom:80%;" />

<p>注意和vector的reserve函数区分，拼写上非常相似。</p>
<p><img src="/will-blog.github.io/./image-20250317155350549.png" alt="image-20250317155350549"></p>
<h5 id="unique函数"><a href="#unique函数" class="headerlink" title="unique函数"></a>unique函数</h5><p>去重list中重复的元素</p>
<p>需要先排序（无论是从小到大还是从大到小），才能够实现效果</p>
<p><img src="/will-blog.github.io/./image-20250317154753075.png" alt="image-20250317154753075"></p>
<h5 id="merge函数"><a href="#merge函数" class="headerlink" title="merge函数"></a>merge函数</h5><p>将一个list合并到当前list中</p>
<p>注意：想要合并后的list结果是有序的，需要<span style=color:red;background:yellow><strong>合并前两个list中的元素先按照从小到大的顺序排好序</strong></span>。</p>
<img src="./image-20250317162046627.png" alt="image-20250317162046627" style="zoom:67%;" />

<p>结果：</p>
<p>nums2中的元素已经合并到nums1中了，nums2的元素被清空了。</p>
<h5 id="splice函数"><a href="#splice函数" class="headerlink" title="splice函数"></a>splice函数</h5><p>还有一个稍稍复杂的特殊操作splice</p>
<p><img src="/will-blog.github.io/./image-20240807100112283-1733123638304-4.png" alt="image-20240807100112283"></p>
<p>第一个参数相当于是移动的目的地</p>
<p><img src="/will-blog.github.io/./image-20240807100952020-1733123638304-5.png" alt="image-20240807100952020"></p>
<p><img src="/will-blog.github.io/./image-20240807101035059-1733123638304-6.png" alt="image-20240807101035059"></p>
<p>如果在同一个链表中进行splice操作</p>
<p><img src="/will-blog.github.io/./image-20240807101633898-1733123638304-7.png" alt="image-20240807101633898"></p>
<p><strong>但是也可能会出现问题（取决于范围有没有交叉）</strong></p>
<p>类似于strcpy，目的字符串与源字符串不要有交叉。同理还有memcpy也是要注意这个问题。</p>
<blockquote>
<p>补充：</p>
<p>splice函数可以帮助我们很方便地实现LRU(Least Recently used)</p>
<p><span style=color:red;background:yellow><strong>LRU:最近最少使用算法</strong></span></p>
<p>一种常用的页面置换算法，用于在有限的内存空间中管理数据缓存，以提高系统性能。</p>
<p>LRU 算法基于一个假设：如果一个数据在最近一段时间内没有被访问，那么在未来它被访问的概率也相对较低。因此，当内存空间不足时，LRU 算法会选择淘汰最近最少使用的数据，为新的数据腾出空间。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">思想：新元素放在前面，老的元素放在后面</span><br><span class="line">比如现在有 <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> 四个元素逐一存到容器中，限制容量为<span class="number">4</span></span><br><span class="line"></span><br><span class="line">刚存放完       插入元素<span class="number">3</span>      插入元素<span class="number">5</span>      插入元素<span class="number">4</span></span><br><span class="line"><span class="number">4</span> <span class="number">3</span> <span class="number">2</span> <span class="number">1</span> ----&gt; <span class="number">3</span> <span class="number">4</span> <span class="number">2</span> <span class="number">1</span> ----&gt; <span class="number">5</span> <span class="number">3</span> <span class="number">4</span> <span class="number">2</span>  ---&gt; <span class="number">4</span> <span class="number">5</span> <span class="number">3</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//假设现在插入元素2   </span></span><br><span class="line"><span class="type">int</span> number = tmp.<span class="built_in">back</span>();</span><br><span class="line">tmp.<span class="built_in">pop_back</span>();</span><br><span class="line">tmp.<span class="built_in">push_front</span>(number);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果明确了是用list存储，可以使用splice函数，</span></span><br><span class="line">tmp.<span class="built_in">splice</span>(tmp.<span class="built_in">begin</span>(), tmp, --tmp.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure>

</blockquote>
<h3 id="关联式容器"><a href="#关联式容器" class="headerlink" title="关联式容器"></a>关联式容器</h3><p>关联式容器包括：set、multiset、map、multimap四种。它们的底层使用的数据结构都是红黑树。要学习它们的使用，可以从：初始化、遍历、查找、插入、删除、针对自定义类型等方面进行学习。</p>
<blockquote>
<ul>
<li>set特征<br>存放的是key类型，key值是唯一的，不能重复<br>默认按照key值进行升序排列</li>
<li>multiset特征<br>存放的是key类型，key值不一定唯一，可以重复<br>默认按照key值进行升序排列</li>
<li>map的特征<br>存放的是key-value类型，key值是唯一的，不能重复，value没有要求是否唯一<br>默认按照关键字key进行升序排列</li>
<li>multimap的特征<br>存放的是key-value类型，key值不一定唯一，可以重复，value没有要求是否唯一<br>默认按照关键字key进行升序排列</li>
</ul>
</blockquote>
<h4 id="set的使用"><a href="#set的使用" class="headerlink" title="set的使用"></a>set的使用</h4><h5 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h5><p><img src="/will-blog.github.io/./image-20250317175534262.png" alt="image-20250317175534262"></p>
<ol>
<li>无参构造</li>
<li>迭代器方式进行构造，传入一个first迭代器，传入一个last迭代器</li>
<li>拷贝构造</li>
<li>标准初始化列表（大括号的形式）</li>
<li></li>
</ol>
<h5 id="基本特征"><a href="#基本特征" class="headerlink" title="基本特征"></a>基本特征</h5><p><img src="/will-blog.github.io/./image-20240807115258806-1733124502629-22.png" alt="image-20240807115258806"></p>
<h5 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h5><p><img src="/will-blog.github.io/./image-20240807112809259-1733124502628-19.png" alt="image-20240807112809259"></p>
<h5 id="insert操作"><a href="#insert操作" class="headerlink" title="insert操作"></a>insert操作</h5><p><img src="/will-blog.github.io/./image-20240807113245685-1733124502629-20.png" alt="image-20240807113245685"></p>
<p><img src="/will-blog.github.io/./image-20240807114212763-1733124502629-21.png" alt="image-20240807114212763"></p>
<p>注意：关联式容器都没有头部插入&#x2F;删除或者尾部插入&#x2F;删除的函数。</p>
<h5 id="erase操作"><a href="#erase操作" class="headerlink" title="erase操作"></a>erase操作</h5><p><img src="/will-blog.github.io/./image-20240807114416260-1733124502629-23.png" alt="image-20240807114416260"></p>
<p><span style=color:red;background:yellow><strong>注意：</strong></span></p>
<p>set不支持下标操作，因为没有operator[]函数</p>
<p><img src="/will-blog.github.io/./image-20240807114916461-1733124502629-25.png" alt="image-20240807114916461"></p>
<p>所以访问set的元素只能通过迭代器方式，但通过迭代器访问到的元素只能进行读操作</p>
<p>set的元素不支持修改</p>
<p><img src="/will-blog.github.io/./image-20240807115114358-1733124502629-24.png" alt="image-20240807115114358"></p>
<h5 id="针对于自定义类型的写法（重要）"><a href="#针对于自定义类型的写法（重要）" class="headerlink" title="针对于自定义类型的写法（重要）"></a>针对于自定义类型的写法（重要）</h5><p><img src="/will-blog.github.io/./image-20240808102542239-1733124502629-26.png" alt="image-20240808102542239"></p>
<p>对于set而言，当Key类型是类类型的时候，那么第二个模板参数Compare默认会采用std::less，但是std::less针对的Key如果不能比较大小，就需要进行改写。</p>
<p>改写的方式有如下三种：<span style=color:red;background:yellow><strong>模板的特化、运算符的重载、函数对象</strong></span></p>
<p>直接定义一个存放Point的set，编译一定会报错，根本原因在于默认的std::less针对Point对象并不知道该如何比较大小</p>
<img src="./image-20250317183935132.png" alt="image-20250317183935132" style="zoom:67%;" />



<blockquote>
<p>std::less是一个通用模板类，针对解决不了的特殊类型，可以想到<span style=color:red;background:yellow><strong>特化模板</strong></span></p>
<p>为std::less准备一个特化版本，这个特化模板类中定义函数调用运算符重载函数，定义一套Point对象的比较规则</p>
<p><img src="/will-blog.github.io/./image-20250318150258925.png" alt="image-20250318150258925"></p>
</blockquote>
<blockquote>
<p>自定义对象的比较规则当然也是自定义的，例如：</p>
<p>定义getDistance获取点到原点的距离，先比较到原点的距离，如果相同再比较横坐标，如果相同再比较纵坐标。</p>
<p><img src="/will-blog.github.io/./image-20250318150348968.png" alt="image-20250318150348968"></p>
</blockquote>
<blockquote>
<p><span style=color:red;background:yellow><strong>注意：</strong></span></p>
<ul>
<li>在operator()函数中需要访问Point的私有成员，可以有两个思路：</li>
</ul>
<p>（1）在自定义类中中作相应的友元声明；</p>
<img src="./image-20241226224935206.png" alt="image-20241226224935206" style="zoom:67%;" />

<p>（2）给Point提供公有的get系列函数，间接访问Point的私有数据成员</p>
<ul>
<li>函数调用运算符重载函数最好设为const函数</li>
</ul>
<p>因为在 C++17 中，std::set 要求比较对象必须是 <strong>常量可调用</strong> 的。模板参数列表中的class Compare在set的底层实现中会创建出对象，并作为函数对象使用，也就是调用operator函数，这个函数需要是const成员函数。</p>
<p>这涉及了set的内部实现的版本演变，此处不做探究。</p>
<img src="./image-20250317192201592.png" alt="image-20250317192201592" style="zoom:67%;" />



<p>参考std::less的operator()函数</p>
<p><img src="/will-blog.github.io/./image-20250317193513788.png" alt="image-20250317193513788"></p>
</blockquote>
<blockquote>
<p>当然，如果让std::less通用模板知道Point对象该怎么比较大小可以做到吗？当然可以，使用<span style=color:red;background:yellow><strong>运算符重载</strong></span>就行。</p>
<p>operator&lt;以友元方式重载</p>
<p><img src="/will-blog.github.io/./image-20240808102807663-1733124502629-28.png" alt="image-20240808102807663"></p>
</blockquote>
<p><strong>这个场景下，如果特化模板与运算符重载同时存在，模板的特化优先级高于运算符重载。</strong></p>
<blockquote>
<p>上面两种方法都是围绕着std::less想办法，我们也可以自已准备Compare类（类似于智能指针的删除器，也可以理解为自定义比较器）</p>
<p>Compare类重载函数调用运算符，set的底层实现中使用Compare类对象作为<span style=color:red;background:yellow><strong>函数对象</strong></span>，以此指示元素的排序。</p>
<p><img src="/will-blog.github.io/./image-20240808102837821-1733124502629-29.png" alt="image-20240808102837821"></p>
</blockquote>
<h4 id="multiset的使用"><a href="#multiset的使用" class="headerlink" title="multiset的使用"></a>multiset的使用</h4><h5 id="基本特征-1"><a href="#基本特征-1" class="headerlink" title="基本特征"></a>基本特征</h5><p>包含于<code>&lt;set&gt;</code>头文件</p>
<p><img src="/will-blog.github.io/./image-20240808110150953-1733124502629-30.png" alt="image-20240808110150953"></p>
<h5 id="其他功能"><a href="#其他功能" class="headerlink" title="其他功能"></a>其他功能</h5><p>multiset的查找功能（count、find）、插入功能（insert）、删除功能（erase）与set是一样的。</p>
<p>multiset也没有下标操作，也同样不支持使用迭代器修改元素。</p>
<h5 id="bound系列函数"><a href="#bound系列函数" class="headerlink" title="bound系列函数"></a>bound系列函数</h5><p>注意：equal_range返回的范围仍然是前闭后开的范围</p>
<img src="./image-20241210101903143.png" alt="image-20241210101903143" style="zoom:67%;" />

<img src="./image-20250318143726479.png" alt="image-20250318143726479" style="zoom:67%;" />

<img src="./image-20250318143624627.png" alt="image-20250318143624627" style="zoom:67%;" />

<img src="./image-20250318143647024.png" alt="image-20250318143647024" style="zoom:67%;" />



<blockquote>
<p>如下，可以用两种方式找出multiset中所有等于key的元素</p>
<p><img src="/will-blog.github.io/./image-20240808111636211-1733124502630-31.png" alt="image-20240808111636211"></p>
</blockquote>
<h5 id="针对于自定义类型"><a href="#针对于自定义类型" class="headerlink" title="针对于自定义类型"></a>针对于自定义类型</h5><p>multiset针对于自定义类型的用法与set完全一样，也有三种形式：模板的特化、函数对象的形式、运算符重载。</p>
<h4 id="map的使用"><a href="#map的使用" class="headerlink" title="map的使用"></a>map的使用</h4><h5 id="基本特征-2"><a href="#基本特征-2" class="headerlink" title="基本特征"></a>基本特征</h5><p><img src="/will-blog.github.io/./image-20240808113609526-1733124502630-32.png" alt="image-20240808113609526"></p>
<h5 id="查找-1"><a href="#查找-1" class="headerlink" title="查找"></a>查找</h5><img src="./image-20250318145851453.png" alt="image-20250318145851453" style="zoom: 80%;" />



<p><img src="/will-blog.github.io/./image-20240808113855833-1733124502630-33.png" alt="image-20240808113855833"></p>
<h5 id="insert操作-1"><a href="#insert操作-1" class="headerlink" title="insert操作"></a>insert操作</h5><p><img src="/will-blog.github.io/./image-20250318145655104.png" alt="image-20250318145655104"></p>
<p>map也有三种插入的方式，插入一个元素、插入迭代器范围的元素、插入大括号范围的元素。</p>
<blockquote>
<p>注意：</p>
<p>插入时是要插入一个或多个pair，而不是插入key或者插入value</p>
<p>插入单个元素可能不成功（这个元素已经存在于map中）</p>
<p><img src="/will-blog.github.io/./image-20240808114453984-1733124502630-34.png" alt="image-20240808114453984"></p>
</blockquote>
<h5 id="erase操作-1"><a href="#erase操作-1" class="headerlink" title="erase操作"></a>erase操作</h5><p><img src="/will-blog.github.io/./image-20240808114701760-1733124502630-35.png" alt="image-20240808114701760"></p>
<p>注意：map可以删除迭代器指向的元素、以及迭代器范围的元素</p>
<h5 id="下标操作（重要）"><a href="#下标操作（重要）" class="headerlink" title="下标操作（重要）"></a>下标操作（重要）</h5><p><img src="/will-blog.github.io/./image-20240808121115356-1733124502630-36.png" alt="image-20240808121115356"></p>
<h5 id="针对于自定义类型-1"><a href="#针对于自定义类型-1" class="headerlink" title="针对于自定义类型"></a>针对于自定义类型</h5><p><img src="/will-blog.github.io/./image-20240808144703570-1733124502630-37.png" alt="image-20240808144703570"></p>
<blockquote>
<p>如果key本身是可比较类型，value是自定义类型，其实不需要额外的操作，map可以正常进行遍历。</p>
<p><img src="/will-blog.github.io/./image-20240808144700093-1733124502630-38.png" alt="image-20240808144700093"></p>
</blockquote>
<blockquote>
<p>如果Key对应的是自定义类型</p>
<p>之前写的函数模板可以遍历前面五种容器的元素，但是map不行</p>
<p>因为map的元素都是pair，而pair不能直接用输出流运算符进行输出。</p>
<p><img src="/will-blog.github.io/./image-20241210115238336.png" alt="image-20241210115238336"></p>
<p>此时有两个display构成函数模板的重载，第一个适用于任意的容器类型，第二个专门用于map类型；</p>
<p>在调用display时会首先尝试调用第二个，如果能匹配则使用，如上图的<code>mps</code>是一个map对象，正好可以使用；</p>
<p>如果不能匹配则尝试调用其他的display模板，如上图的<code>pts</code>显然是无法匹配map&lt;T1,T2&gt;的，所以无法使用第二个模板，当然如果想要使用第一个函数模板，还需要为Point重载输出流运算符。</p>
</blockquote>
<p>上述讨论仅仅是解决map元素的遍历问题，想要成功完成创建，仍然要让编译器能够根据key值给map的元素排序。</p>
<p>给Point重载&lt;运算符，或者针对Point特化std::less，代码都可以直接通过。</p>
<blockquote>
<p>但如果用的是函数对象的方法，在遍历时还需要一点改动。</p>
<img src="./image-20241210171242405.png" alt="image-20241210171242405" style="zoom:67%;" /></blockquote>
<h4 id="multimap的使用"><a href="#multimap的使用" class="headerlink" title="multimap的使用"></a>multimap的使用</h4><h5 id="基本特征-3"><a href="#基本特征-3" class="headerlink" title="基本特征"></a>基本特征</h5><p><img src="/will-blog.github.io/./image-20240808145243572-1733124502630-39.png" alt="image-20240808145243572"></p>
<h5 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h5><p>multimap的查找功能（count、find）、插入功能（insert）、删除功能（erase）与map是一样的。</p>
<h5 id="不支持下标"><a href="#不支持下标" class="headerlink" title="不支持下标"></a>不支持下标</h5><p><img src="/will-blog.github.io/./image-20240808145436542-1733124502630-40.png" alt="image-20240808145436542"></p>
<h5 id="针对于自定义类型-2"><a href="#针对于自定义类型-2" class="headerlink" title="针对于自定义类型"></a>针对于自定义类型</h5><p>使用方式与map完全一样。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>1、关联式容器中的元素会按照key进行排序。</p>
<p>2、底层使用的都是红黑树数据结构</p>
<p>3、<font color=red><strong>map是具备下标的，其他三种关联式容器没有下标</strong></font>。</p>
<h3 id="无序关联式容器"><a href="#无序关联式容器" class="headerlink" title="无序关联式容器"></a>无序关联式容器</h3><img src="./image-20241210143437004.png" alt="image-20241210143437004" style="zoom: 80%;"/>

<p>无序关联式容器底层是哈希表实现的。</p>
<p>首先来回顾一下哈希表</p>
<h4 id="哈希相关的概念"><a href="#哈希相关的概念" class="headerlink" title="哈希相关的概念"></a>哈希相关的概念</h4><p>哈希(过程)：</p>
<ol>
<li>哈希是一种可以接受各种类型、大小的输入，输出一个固定长度整数的过程。</li>
<li>你可以将哈希理解成一种特殊的映射，将一个理论无限的集合A映射到有限整数集合B上。</li>
</ol>
<p><strong>哈希函数</strong>：哈希函数是哈希过程的核心，它决定了哈希映射过程的规则。</p>
<p><strong>哈希冲突</strong>：哈希是一种化无限为有限的映射。理想中的映射应该做到一一对应，即“不同的输入一定得到不同的输出，同样的输入一定得到同样的输出”。但这种理想情况其实是做不到的。退而求其次，在实际使用中我们允许出现多对一（不同输入得到相同输出），但绝不允许出现一对多（相同输入得到不同输出）。</p>
<p>若映射中出现多对一，就是哈希冲突。哈希冲突可以减少，但绝不可能没有。</p>
<p>可以通过key找到在表中的位置</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">index = <span class="built_in">H</span>(key)</span><br></pre></td></tr></table></figure>



<blockquote>
<p><span style=color:red;background:yellow><strong>如何构建哈希函数</strong></span></p>
<p>定址法： H(key) &#x3D; a * key + b<br><font color=red><strong>平方取中法</strong></font>： key^2 &#x3D; 1234^2 &#x3D; 1522756 ——&gt;227<br>数字分析法：H(key) &#x3D; key % 10000；<br>除留取余法：H(key) &#x3D; key mod p (p &lt;&#x3D; m, m为表长)  </p>
</blockquote>
<p>哈希函数之所以要设计得这么复杂，就是为了尽量减少哈希冲突</p>
<p>不同的key值所对应的位置一样，这就是哈希冲突</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">key1 != key2</span><br><span class="line"><span class="built_in">H</span>(key1) = <span class="built_in">H</span>(key2)  </span><br></pre></td></tr></table></figure>

<h5 id="如何解决哈希冲突"><a href="#如何解决哈希冲突" class="headerlink" title="如何解决哈希冲突"></a>如何解决哈希冲突</h5><p>开放定址法<br><font color=red>**链地址法 **</font>(推荐使用这种，这也是STL中使用的方法)<br>再散列法<br>建立公共溢出区  </p>
<p><img src="/will-blog.github.io/./image-20240808151302071-1733125193831-63.png" alt="image-20240808151302071"></p>
<p>那么表长应该如何设计比较合理？</p>
<p>这里还涉及到一个概念——<font color=red><strong>装载因子</strong></font>，或者称为装填因子。</p>
<p>装载因子a &#x3D; 元素的个数&#x2F;表长，一般是一个小数。如果装载因子的值比较大，冲突的概率比较大，空间利用率比较高；如果装载因子的值比较小，冲突的概率比较低，空间利用率比较低；需要做一个权衡，一般设置在0.5~0.75左右。</p>
<h4 id="unordered-set的使用"><a href="#unordered-set的使用" class="headerlink" title="unordered_set的使用"></a>unordered_set的使用</h4><p>unordered_set在使用时除了元素的类型，还需要关注几个模板参数</p>
<p>Hash决定了具体使用怎样的哈希函数，通过Hash类的operator()函数确定，而哈希冲突的解决方式则是由容器内部的实现机制确定的；</p>
<p>KeyEqual决定了元素的判重方式，同样也是通过operator()函数确定。</p>
<p>对于内置类型和指针类型，可以直接使用这一容器，如果是自定义类型对象作为元素，则需要为其准备这些模板参数。</p>
<img src="./image-20241212113324137.png" alt="image-20241212113324137" style="zoom:67%;" />





<h5 id="基本特征-4"><a href="#基本特征-4" class="headerlink" title="基本特征"></a>基本特征</h5><p>创建unorder_set的方式和之前的容器没有多大区别。</p>
<p><img src="/will-blog.github.io/./image-20240808153120111-1733125234824-65.png" alt="image-20240808153120111"></p>
<img src="./image-20241212115621977.png" alt="image-20241212115621977" style="zoom:80%;" />

<p>无序 + 去重的效果</p>
<h5 id="其他操作-1"><a href="#其他操作-1" class="headerlink" title="其他操作"></a>其他操作</h5><p>unordered_set的查找（count、find）、插入（insert）、删除（erase）等常用操作与set完全一样。也不支持下标。</p>
<h5 id="针对于自定义类型（重要）"><a href="#针对于自定义类型（重要）" class="headerlink" title="针对于自定义类型（重要）"></a>针对于自定义类型（重要）</h5><p><img src="/will-blog.github.io/./image-20240808155505140-1733125234824-68.png" alt="image-20240808155505140"></p>
<p>针对于自定义类型而言，可能需要改写第二个模板参数Hash与第三个模板参数KeyEqual。</p>
<p>Hash的默认采用的是std::hash，所以可以改写的方案有两种：模板的特化、函数对象的形式，与运算符重载没有什么关系。</p>
<p><img src="/will-blog.github.io/./image-20240808163638815-1733125234824-66.png" alt="image-20240808163638815"></p>
<p><img src="/will-blog.github.io/./image-20240808163705044-1733125234824-67.png" alt="image-20240808163705044"></p>
<p>第三个模板参数KeyEqual的传参有三种方式：模板的特化、函数对象的形式、运算符重载。</p>
<p><img src="/will-blog.github.io/./image-20240808163825379-1733125234824-70.png" alt="image-20240808163825379"></p>
<p><img src="/will-blog.github.io/./image-20240808163848707-1733125234824-69.png" alt="image-20240808163848707"></p>
<p><img src="/will-blog.github.io/./image-20240808163930278-1733125234824-71.png" alt="image-20240808163930278"></p>
<h4 id="unordered-multiset的使用"><a href="#unordered-multiset的使用" class="headerlink" title="unordered_multiset的使用"></a>unordered_multiset的使用</h4><h5 id="基本特征-5"><a href="#基本特征-5" class="headerlink" title="基本特征"></a>基本特征</h5><p><img src="/will-blog.github.io/./image-20240808170654309-1733125234824-72.png" alt="image-20240808170654309"></p>
<h5 id="其他操作-2"><a href="#其他操作-2" class="headerlink" title="其他操作"></a>其他操作</h5><p>unordered_multiset的查找（count、find）、插入（insert）、删除（erase）与multiset完全一样。也不支持下标。</p>
<h5 id="针对于自定义类型-3"><a href="#针对于自定义类型-3" class="headerlink" title="针对于自定义类型"></a>针对于自定义类型</h5><p>unordered_multiset针对于自定义类型的写法与unordered_set的用法一样，需要改写第二个参数Hash与第三个参数KeyEqual。</p>
<h4 id="unordered-map的使用"><a href="#unordered-map的使用" class="headerlink" title="unordered_map的使用"></a>unordered_map的使用</h4><h5 id="基本特征-6"><a href="#基本特征-6" class="headerlink" title="基本特征"></a>基本特征</h5><p><img src="/will-blog.github.io/./image-20240808171339880-1733125234824-73.png" alt="image-20240808171339880"></p>
<h5 id="其他操作-3"><a href="#其他操作-3" class="headerlink" title="其他操作"></a>其他操作</h5><p>unordered_map的查找（count、find）、插入（insert）、删除（erase）与map是完全一样的。</p>
<h5 id="支持下标（-重要-）"><a href="#支持下标（-重要-）" class="headerlink" title="支持下标（&#x3D;&#x3D;重要&#x3D;&#x3D;）"></a>支持下标（&#x3D;&#x3D;重要&#x3D;&#x3D;）</h5><p><img src="/will-blog.github.io/./image-20240808171527718-1733125234824-74.png" alt="image-20240808171527718"></p>
<h4 id="unordered-multimap的使用"><a href="#unordered-multimap的使用" class="headerlink" title="unordered_multimap的使用"></a>unordered_multimap的使用</h4><h5 id="基本特征-7"><a href="#基本特征-7" class="headerlink" title="基本特征"></a>基本特征</h5><p><img src="/will-blog.github.io/./image-20240808172135639-1733125234825-75.png" alt="image-20240808172135639"></p>
<h5 id="其他操作-4"><a href="#其他操作-4" class="headerlink" title="其他操作"></a>其他操作</h5><p>unordered_multimap的查找（count、find）、插入（insert）、删除（erase）与multimap是完全一样的。</p>
<h5 id="不支持下标-1"><a href="#不支持下标-1" class="headerlink" title="不支持下标"></a>不支持下标</h5><p><img src="/will-blog.github.io/./image-20240808172248938-1733125234825-76.png" alt="image-20240808172248938"></p>
<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>1、无序关联式容器中的元素是<strong>没有顺序的</strong>。</p>
<p>2、底层使用的都是<strong>哈希表</strong>数据结构</p>
<p>3、unordered_map是具备下标的，其他三种无序关联式容器没有下标。</p>
<h3 id="容器的选择（重要）"><a href="#容器的选择（重要）" class="headerlink" title="容器的选择（重要）"></a>容器的选择（重要）</h3><p><strong>元素是不是有顺序的</strong></p>
<p>如果元素是有顺序的，首选的是关联式容器，不应该选择的是无序关联式容器。其次可以选择序列式容器。</p>
<p>序列式容器中的元素也可以排序，list中是有sort函数的，对于vector与deque可以借鉴算法库中的sort函数进行排序。</p>
<img src="./image-20241213115102389.png" alt="image-20241213115102389" style="zoom:80%;" />



<p><strong>迭代器的类型</strong></p>
<p>随机访问迭代器：vector、deque</p>
<p>双向迭代器：list、关联式容器</p>
<p>前向迭代器：无序关联式容器</p>
<p><strong>查找的时间复杂度</strong></p>
<p>序列式容器：时间复杂度O(N)</p>
<p>关联式容器：时间复杂度O(logN)</p>
<p>无序关联式容器：时间复杂度O(1)</p>
<p><strong>是否支持下标</strong></p>
<p>序列式容器：vector、deque</p>
<p>关联式容器：map</p>
<p>无序关联式容器：unordered_map</p>
<h3 id="容器适配器"><a href="#容器适配器" class="headerlink" title="容器适配器"></a>容器适配器</h3><p>容器适配器的作用</p>
<img src="./image-20241213152152135.png" alt="image-20241213152152135" style="zoom:67%;" />



<p>栈(stack)</p>
<img src="./image-20241213155815990.png" alt="image-20241213155815990" style="zoom:67%;" />



<p>队列(queue)</p>
<img src="./image-20241213160014049.png" alt="image-20241213160014049" style="zoom: 67%;" />





<h4 id="优先级队列"><a href="#优先级队列" class="headerlink" title="优先级队列"></a>优先级队列</h4><p><img src="/will-blog.github.io/./image-20240809102130717-1733126644616-89.png" alt="image-20240809102130717"></p>
<p><img src="/will-blog.github.io/./image-20241213161252492.png" alt="image-20241213161252492"></p>
<img src="./image-20241213161347228.png" alt="image-20241213161347228" style="zoom:67%;" />

<p>对于vector或者deque，value_type就是T，即priority_queue的Compare要提供的是对容器中元素的比较方式。</p>
<h5 id="基本使用方法"><a href="#基本使用方法" class="headerlink" title="基本使用方法"></a>基本使用方法</h5><p>对优先级队列的元素进行遍历，以前常用的几种方式都不支持（下标、迭代器、增强for循环）</p>
<p>参考C语言中对栈或者队列中元素遍历的方式</p>
<p>以下的遍历实际上是清空式的遍历，遍历完后优先级队列实际上没有元素了。如果不想进行清空式的遍历，可以在遍历之前先复制一次priority_queue</p>
<p><img src="/will-blog.github.io/./image-20240809105418557-1733126644617-91.png" alt="image-20240809105418557"></p>
<img src="./image-20241213172224047.png" alt="image-20241213172224047" style="zoom:67%;" />



<p>默认的compare是std::less，最终呈现的效果为什么是从大到小，而不是从小到大呢？</p>
<p>稍微修改一下代码，往空的优先级队列添加元素，观察填充过程</p>
<img src="./image-20241216102425310.png" alt="image-20241216102425310" style="zoom:67%;" />



<p>优先级队列使用了大根堆，其过程：</p>
<p>当有元素插入的时候，会将该元素与堆顶进行比较（细节上实际是一级一级比较），如果堆顶比新插入的元素要小，就会满足std::less，会将新插入的元素作为新的堆顶；</p>
<p>如果新插入的元素与堆顶进行比较，堆顶比新插入的元素要大，那么就不满足std::less，就不会进行置换，上一次的堆顶仍然是堆顶。</p>
<h5 id="使用函数总结"><a href="#使用函数总结" class="headerlink" title="使用函数总结"></a>使用函数总结</h5><p>判空：empty;<br>元素的个数:size;<br>插入:push;<br>删除：pop;<br>获取top元素:top;<br>交换函数:swap;<br>注意，没有迭代器的概念。</p>
<h5 id="针对于自定义类型-4"><a href="#针对于自定义类型-4" class="headerlink" title="针对于自定义类型"></a>针对于自定义类型</h5><p>因为优先级队列的第三个模板参数使用的是Compare，默认值是std::less,所以如果自定义类型不能进行比较，就需要进行改写，改写的方案与set针对于Compare的改写方式完全一样，有三种：模板的特化、函数对象的形式、运算符重载。</p>
<p>请尝试实现一下使用优先级队列存放Point对象。</p>
<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>可以将迭代器看成是一种指针，但是不完全是指针，因为有些时候迭代器是一个类类型，然后重载了指针的功能，所以迭代器可以像指针一样使用。</p>
<p>—— C++为什么要设计迭代器这种东西？</p>
<p>迭代器算是C++一个非常重要的抽象概念，它的意义在于：</p>
<ul>
<li>为访问容器中的元素提供了统一的方式。比如vector&#x2F;deque&#x2F;list三种容器存储元素的方式完全不同，存储元素的类型也可能不同，但是都可以用迭代器来遍历和操作容器中的元素，而不需要关心容器的具体实现细节。</li>
<li>使算法能够独立于容器进行设计和实现。例如，std::sort算法可以对任何支持随机访问迭代器的容器进行排序，而不需要为每种容器单独实现排序算法。这样可以提高代码的可复用性和灵活性。</li>
</ul>
<p>也就是说C++通过迭代器把不同的容器的元素的访问逻辑抽象了出来。</p>
<h3 id="迭代器的类型"><a href="#迭代器的类型" class="headerlink" title="迭代器的类型"></a>迭代器的类型</h3><p>输入迭代器(InputIterator)、输出迭代器(OutputIterator)、前向迭代器(ForwardIterator)、双向迭代器(BidirectionIterator)、随机访问迭代器(RandomAccessIterator)</p>
<img src="./image-20250102105616784.png" alt="image-20250102105616784" style="zoom:80%;" />



<p>五种迭代器之间的关系（继承关系）</p>
<img src="./image-20240809114205549-1733126659853-98.png" alt="image-20240809114205549" style="zoom:67%;" />



<blockquote>
<p>举个简单的例子，根据我们对继承关系的了解，我们可以推测出：</p>
<p><img src="/will-blog.github.io/./image-20250102114216223.png" alt="image-20250102114216223"></p>
</blockquote>
<p>为什么要定义这么多种迭代器呢？</p>
<p>为了物尽其用，使得具体的操作使用具体类型的迭代器，避免迭代器的功能太大或者太小，导致使用起来不方便。每个容器及其对应的迭代器的类型图表如下：</p>
<img src="./image-20250102114702572.png" alt="image-20250102114702572" style="zoom: 67%;" />







<h3 id="流迭代器"><a href="#流迭代器" class="headerlink" title="流迭代器"></a>流迭代器</h3><h4 id="输出流迭代器"><a href="#输出流迭代器" class="headerlink" title="输出流迭代器"></a>输出流迭代器</h4><p>流迭代器是特殊的迭代器，可以将输入&#x2F;输出流作为<strong>容器</strong>看待(因为输入输出都有<strong>缓冲区</strong>的概念)，可以用来存数据。因此，任何接受迭代器参数的算法都可以和流一起工作。</p>
<p>先通过cpp参考文档看到输出流迭代器构造函数的说明</p>
<img src="./image-20250102152744535.png" alt="image-20250102152744535" style="zoom:67%;" />





<p>尝试使用一下输出流迭代器，如下（使用了algorithm提供的copy函数）</p>
<p><img src="/will-blog.github.io/./image-20250318195617489.png" alt="image-20250318195617489"></p>
<img src="./image-20250102153042767.png" alt="image-20250102153042767" style="zoom:67%;" />



<img src="./image-20250102152333957.png" alt="image-20250102152333957" style="zoom:67%;" />

<p>其实结果很容易推测出来。至此，我们发现又多了一种遍历容器元素的方式，那么这个输出的效果是怎么实现的呢？</p>
<p>—— 通过源码来认识。</p>
<p>输出流迭代器的类模板形式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>,</span><br><span class="line">          <span class="keyword">class</span> <span class="title class_">_CharT</span> = <span class="type">char</span>, <span class="keyword">class</span> _Traits = char_traits&lt;_CharT&gt; &gt;</span><br><span class="line"><span class="keyword">class</span> ostream_iterator </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//根据上述例子中的构造方式</span></span><br><span class="line">    <span class="comment">//__s = cout;</span></span><br><span class="line">    <span class="comment">// __c = &quot; &quot;;</span></span><br><span class="line">    <span class="comment">//_M_stream = &amp;cout;</span></span><br><span class="line">    <span class="comment">//_M_string = &quot;  &quot;</span></span><br><span class="line">    <span class="built_in">ostream_iterator</span>(ostream_type&amp; __s, <span class="type">const</span> _CharT* __c) </span><br><span class="line">    : _M_stream(&amp;__s)</span><br><span class="line">    , _M_string(__c)  </span><br><span class="line">    &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    ostream_iterator&lt;_Tp&gt;&amp; <span class="keyword">operator</span>*() &#123; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">    ostream_iterator&lt;_Tp&gt;&amp; <span class="keyword">operator</span>++() &#123; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125; </span><br><span class="line">    ostream_iterator&lt;_Tp&gt;&amp; <span class="keyword">operator</span>++(<span class="type">int</span>) &#123; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">    </span><br><span class="line">    ostream_iterator&lt;_Tp&gt;&amp; <span class="keyword">operator</span>=(<span class="type">const</span> _Tp&amp; __value) </span><br><span class="line">    &#123; </span><br><span class="line">        *_M_stream &lt;&lt; __value;<span class="comment">//cout &lt;&lt; 1</span></span><br><span class="line">        <span class="keyword">if</span> (_M_string) *_M_stream &lt;&lt; _M_string;<span class="comment">//cout &lt;&lt; &quot;  &quot;</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  ostream_type* _M_stream;</span><br><span class="line">  <span class="type">const</span> _CharT* _M_string</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<p>copy函数的实现（cpp参考文档相关页直接给出）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> InputIt, <span class="keyword">class</span> OutputIt&gt;</span></span><br><span class="line"><span class="function">OutputIt <span class="title">copy</span><span class="params">(InputIt first, InputIt last, OutputIt d_first)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (first != last) &#123;</span><br><span class="line">        *d_first++ = *first++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d_first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>以上述例子为参考进行分析</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//copy(vec.begin(), vec.end(), osi);</span></span><br><span class="line"><span class="comment">//first = vec.begin();</span></span><br><span class="line"><span class="comment">//last = vec.end()</span></span><br><span class="line"><span class="comment">//d_first = osi </span></span><br><span class="line"><span class="function">OutputIt <span class="title">copy</span><span class="params">(InputIt first, InputIt last, OutputIt d_first)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (first != last) &#123;</span><br><span class="line">        *d_first++ = *first++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d_first;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//******分析过程**********</span></span><br><span class="line">osi = <span class="number">1</span> <span class="comment">//ostream_iterator调用operator=函数</span></span><br><span class="line">        last</span><br><span class="line"><span class="number">1</span> <span class="number">5</span> <span class="number">9</span> <span class="number">7</span></span><br><span class="line">f ------&gt; f</span><br></pre></td></tr></table></figure>



<h4 id="输入流迭代器"><a href="#输入流迭代器" class="headerlink" title="输入流迭代器"></a>输入流迭代器</h4><p>有了输出流迭代器的基本认知后，我们再来看看输入流迭代器</p>
<p>首先是它的构造函数</p>
<img src="./image-20250103091012302.png" alt="image-20250103091012302" style="zoom:67%;" />



<p>可以利用一个通用输入流对象初始化istream_iterator</p>
<img src="./image-20250103090859551.png" alt="image-20250103090859551" style="zoom:67%;" />





<p>根据推测可能写出这样的代码，但是会出现段错误</p>
<img src="./image-20250103114516852.png" alt="image-20250103114516852" style="zoom:67%;" />



<p>正确使用</p>
<img src="./image-20250103114847667.png" alt="image-20250103114847667" style="zoom:67%;" />



<p>通过源码进行理解</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>, </span><br><span class="line">          <span class="keyword">class</span> <span class="title class_">_CharT</span> = <span class="type">char</span>, <span class="keyword">class</span> _Traits = char_traits&lt;_CharT&gt;,</span><br><span class="line">          <span class="keyword">class</span> _Dist = <span class="type">ptrdiff_t</span>&gt; </span><br><span class="line"><span class="keyword">class</span> istream_iterator </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//无参构造</span></span><br><span class="line">    <span class="built_in">istream_iterator</span>() </span><br><span class="line">    : _M_stream(<span class="literal">nullptr</span>)</span><br><span class="line">    , _M_ok(<span class="literal">false</span>) &#123;&#125;  </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//接收一个输入流对象的构造函数</span></span><br><span class="line">    <span class="comment">//__s = cin;</span></span><br><span class="line">    <span class="comment">//_M_stream = &amp;cin;</span></span><br><span class="line">    <span class="built_in">istream_iterator</span>(istream_type&amp; __s) </span><br><span class="line">    : _M_stream(&amp;__s) </span><br><span class="line">    &#123;</span><br><span class="line">        _M_read(); </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">void</span> _M_read() </span><br><span class="line">    &#123;</span><br><span class="line">        _M_ok = (_M_stream &amp;&amp; *_M_stream) ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (_M_ok) </span><br><span class="line">        &#123;</span><br><span class="line">            *_M_stream &gt;&gt; _M_value;<span class="comment">//cin &gt;&gt; _M_value;</span></span><br><span class="line">            <span class="comment">//输入流的状态非goodbit时才会结束输入行为</span></span><br><span class="line">            _M_ok = *_M_stream ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">bool</span> _M_equal(<span class="type">const</span> istream_iterator&amp; __y) <span class="type">const</span></span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">return</span> (_M_ok == __y._M_ok) &amp;&amp; (!_M_ok || _M_stream == __y._M_stream); </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    istream_iterator <span class="keyword">operator</span>++(<span class="type">int</span>)  </span><br><span class="line">    &#123;</span><br><span class="line">        istream_iterator __tmp = *<span class="keyword">this</span>;</span><br><span class="line">        _M_read();</span><br><span class="line">        <span class="keyword">return</span> __tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    reference <span class="keyword">operator</span>*() <span class="type">const</span> &#123; <span class="keyword">return</span> _M_value; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  istream_type* _M_stream;</span><br><span class="line">  _Tp _M_value;</span><br><span class="line">  <span class="type">bool</span> _M_ok;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> istream_iterator&amp; __x, <span class="type">const</span> istream_iterator&amp; __y) </span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> !__x._M_equal(__y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//例子中使用copy函数的语句</span></span><br><span class="line"><span class="comment">//std::copy(isi, istream_iterator&lt;int&gt;(), std::back_inserter(vec));</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// first = isi;</span></span><br><span class="line"><span class="comment">//last = istream_iterator&lt;int&gt;()</span></span><br><span class="line"><span class="comment">//d_first = std::back_inserter(vec)</span></span><br><span class="line"><span class="function">OutputIt <span class="title">copy</span><span class="params">(InputIt first, InputIt last, OutputIt d_first)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (first != last) &#123; <span class="comment">//两个输入流迭代器对象进行!=比较，其必然对!=符号进行了重载</span></span><br><span class="line">        *d_first++ = *first++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d_first;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>back_insert_iterator的实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Container</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> back_insert_iterator&lt;_Container&gt; <span class="title">back_inserter</span><span class="params">(_Container&amp; __x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">back_insert_iterator</span>&lt;_Container&gt;(__x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">back_insert_iterator</span> &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  _Container* container;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//container = &amp;vec;</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">back_insert_iterator</span><span class="params">(_Container&amp; __x)</span> </span></span><br><span class="line"><span class="function">   : container(&amp;__x) &#123;</span>&#125;</span><br><span class="line">    </span><br><span class="line">   back_insert_iterator&lt;_Container&gt;&amp; </span><br><span class="line">   <span class="keyword">operator</span>=(<span class="type">const</span> <span class="keyword">typename</span> _Container::value_type&amp; __value) </span><br><span class="line">   &#123; </span><br><span class="line">    container-&gt;<span class="built_in">push_back</span>(__value);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">    back_insert_iterator&lt;_Container&gt;&amp; <span class="keyword">operator</span>*() &#123; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">  back_insert_iterator&lt;_Container&gt;&amp; <span class="keyword">operator</span>++() &#123; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">  back_insert_iterator&lt;_Container&gt;&amp; <span class="keyword">operator</span>++(<span class="type">int</span>) &#123; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h3 id="迭代器适配器"><a href="#迭代器适配器" class="headerlink" title="迭代器适配器"></a>迭代器适配器</h3><h4 id="三组插入迭代器适配器（掌握）"><a href="#三组插入迭代器适配器（掌握）" class="headerlink" title="三组插入迭代器适配器（掌握）"></a>三组插入迭代器适配器（掌握）</h4><img src="./image-20250103181150482.png" alt="image-20250103181150482" style="zoom:67%;" />



<p>back_inserter是函数，该函数的返回类型是back_insert_iterator，它们的底层会调用容器的push_back。</p>
<p>front_inserter是函数，该函数的返回类型是front_insert_iterator，它们的底层会调用容器的push_front。</p>
<p>inserter是函数，该函数的返回类型是insert_iterator，它们的底层会调用容器的insert。</p>
<p>看一个简单的例子</p>
<p>要将list的元素插入到vector尾部，除了以往的常规方式（遍历list的元素，再使用vector的push_back函数添加这些元素），还可以使用上迭代器。</p>
<img src="./image-20250106111219439.png" alt="image-20250106111219439" style="zoom:67%;" />



<p>—— 再将vector的元素插入到list头部</p>
<img src="./image-20250106111304333.png" alt="image-20250106111304333" style="zoom:67%;" />

<img src="./image-20250106144924432.png" alt="image-20250106144924432" style="zoom:67%;" />

<p>从得到的结果可以想到，执行的过程是从头到尾遍历vector的元素，然后一次次执行了push_front函数。、</p>
<p>那么，可不可以将list元素插入到vector头部呢？</p>
<p>—— 将list的元素插入到set中</p>
<p><img src="/will-blog.github.io/./image-20240809164112172-1733126659852-96.png" alt="image-20240809164112172"></p>
<p><font color=red><strong>注意：使用上述三种插入迭代器的时候，如果容器本身不具备对应插入函数的话，那么就不能乱用。</strong></font></p>
<h4 id="反向迭代器适配器"><a href="#反向迭代器适配器" class="headerlink" title="反向迭代器适配器"></a>反向迭代器适配器</h4><p><img src="/will-blog.github.io/./image-20240809170644459-1733126659852-95.png" alt="image-20240809170644459"></p>
<p>注意遍历时偏移的方式，仍然是自增</p>
<p><img src="/will-blog.github.io/./image-20240809171255460-1733126659853-99.png" alt="image-20240809171255460"></p>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>STL的算法库中的函数，都是属于普通函数（并不是哪一个类的成员函数）</p>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul>
<li>非修改式的序列算法 <strong>for_each</strong>、count、find</li>
<li>修改式的序列算法  <strong>copy</strong>、<strong>remove_if</strong>、remove、replace、fill</li>
<li>排序函数  <strong>sort</strong></li>
<li>二分搜索的算法  lower_bound、upper_bound、equal_range</li>
<li>集合操作 <strong>set_intersection</strong>（取交集）</li>
<li>堆相关的函数  make_heap、push_heap</li>
<li>取最值  max、min</li>
<li>数值操作 itoa</li>
<li>未初始化的内存操作  <strong>uninitialized_copy</strong></li>
</ul>
<h3 id="for-each函数的使用"><a href="#for-each函数的使用" class="headerlink" title="for_each函数的使用"></a>for_each函数的使用</h3><p>首先看看cpp参考文档的描述</p>
<img src="./image-20250110103033784.png" alt="image-20250110103033784" style="zoom:67%;" />

<p>第三个参数需要传一个一元函数（或者仿函数），其函数形参只有一个（不一定要有const或者&amp;）</p>
<p>一元函数：函数的参数只有一个；</p>
<p>二元函数：函数的参数只有两个。</p>
<p>来看一个简单的应用</p>
<img src="./image-20250110104510905.png" alt="image-20250110104510905" style="zoom:67%;" />



<p>想要通过for_each改变vector中元素的内容，就得在func函数上做文章，可以给func函数形参改成引用。</p>
<p><font color=red><strong>实际使用时，f函数是否改变容器元素，for_each是没有限制的</strong></font></p>
<p>参考for_each的源码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> InputIt, <span class="keyword">class</span> UnaryFunction&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> UnaryFunction <span class="title">for_each</span><span class="params">(InputIt first, InputIt last, UnaryFunction f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (; first != last; ++first) &#123;</span><br><span class="line">        <span class="built_in">f</span>(*first);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="lambda表达式-重要"><a href="#lambda表达式-重要" class="headerlink" title="lambda表达式(重要)"></a>lambda表达式(重要)</h3><p>以for_each的使用为例，有时为了使用一些简单的函数，会经常使用到lambda表达式</p>
<img src="./image-20250110141631261.png" alt="image-20250110141631261" style="zoom:67%;" />

<h4 id="语法结构"><a href="#语法结构" class="headerlink" title="语法结构"></a>语法结构</h4><p>lambda表达式也成为匿名函数，其基本语法结构如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[capture](params) opt -&gt; retureType</span><br><span class="line">&#123;</span><br><span class="line">body;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中capture是捕获列表，params是参数列表，opt是函数选项，retureType是返回值类型，body是函数体。</p>
<p>如下的lambda表达式中</p>
<p>[] 捕获列表：捕获lambda表达式函数体外的局部变量；</p>
<p>() 函数的参数列表</p>
<p>{} 函数的函数体</p>
<img src="./image-20250110151601816.png" alt="image-20250110151601816" style="zoom:67%;" />

<p>如果没有在[]中捕获a、b，那么在匿名函数的函数体中无法访问它们</p>
<p>进一步的，还可以给匿名函数增加函数参数，以及指定函数返回类型</p>
<img src="./image-20250110154439061.png" alt="image-20250110154439061" style="zoom:67%;" />



<p><span style=color:red;background:yellow><strong>注意：</strong></span></p>
<p>捕获列表捕获的是局部变量，全局变量不需要捕获。</p>
<img src="./image-20250110154541870.png" alt="image-20250110154541870" style="zoom:67%;" />



<h4 id="引用捕获与值捕获的区别"><a href="#引用捕获与值捕获的区别" class="headerlink" title="引用捕获与值捕获的区别"></a>引用捕获与值捕获的区别</h4><p>如果想要通过捕获列表改变局部变量的值</p>
<img src="./image-20250110163859032.png" alt="image-20250110163859032" style="zoom:67%;" />



<p>函数选项的位置加上mutable关键字才能对局部变量a&#x2F;b进行修改操作，但这样做也并不能修改a和b实际的值</p>
<img src="./image-20250110164140708.png" alt="image-20250110164140708" style="zoom:67%;" />



<p>看到上述的结果，应该能联想到常规函数的值传递场景，想要真正通过形参改变实参，形参需要写成引用形式。</p>
<p>那么对于匿名函数而言，如果想要在匿名函数中修改捕获的变量其本身的值，那么应该采用的是<font color=red><strong>引用捕获</strong></font></p>
<img src="./image-20250110164446682.png" alt="image-20250110164446682" style="zoom:67%;" />



<p><strong>另外，对于全局变量和函数参数，匿名函数中可以直接完成修改。</strong></p>
<p>如果需要捕获的内容太多，有一些比较方便的写法：</p>
<ul>
<li><p>如果想将外部局部变量全部捕获，可以在捕获列表中使用&#x3D;，表示全部是值捕获；或者使用&amp;，表示全部是引用捕获。</p>
</li>
<li><p>如果某一个变量是值捕获，其他的全部是引用捕获，可以[&amp;, num];</p>
</li>
<li><p>如果某一个变量是引用捕获，其他的全部是值捕获，可以[&#x3D;, &amp;num];</p>
</li>
<li><p>最简单的方式是，将每个变量的捕获形式单独写出来，理解起来更简单。</p>
</li>
</ul>
<img src="./image-20250110165702217.png" alt="image-20250110165702217" style="zoom:67%;" />







<h4 id="lambda表达式可以被接收"><a href="#lambda表达式可以被接收" class="headerlink" title="lambda表达式可以被接收"></a>lambda表达式可以被接收</h4><p>现在考虑到一个问题，在前面的例子中，匿名函数每次都是当场定义当场调用的，那么匿名函数是否可以像普通的函数一样去复用呢？</p>
<p><img src="/will-blog.github.io/./image-20240810112342157-1733126757209-108.png" alt="image-20240810112342157"></p>
<p>对lambda表达式有了一定了解之后，我们可以看看这个小练习</p>
<p>以下的写法哪些是对的，哪些是有问题的？</p>
<p>（1）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> x1 = [] &#123;<span class="keyword">return</span> _number; &#125;;</span><br><span class="line">        <span class="keyword">auto</span> x2 = [<span class="keyword">this</span>] &#123;<span class="keyword">return</span> _number; &#125;; </span><br><span class="line">        <span class="keyword">auto</span> x3 = [<span class="keyword">this</span>] &#123;<span class="keyword">return</span> _number + x + y; &#125;; </span><br><span class="line">        <span class="keyword">auto</span> x4 = [<span class="keyword">this</span>, x, y] &#123;<span class="keyword">return</span> _number + x + y; &#125;; </span><br><span class="line">        <span class="keyword">auto</span> x5 = [<span class="keyword">this</span>] &#123;<span class="keyword">return</span> _number++; &#125;; </span><br><span class="line">        <span class="keyword">auto</span> x6 = [=] &#123;<span class="keyword">return</span> _number + x + y; &#125;;</span><br><span class="line">        <span class="keyword">auto</span> x7 = [&amp;] &#123;<span class="keyword">return</span> _number + x + y; &#125;; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> _number = <span class="number">100</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>（2）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>, b = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">auto</span> f1 = [] &#123;<span class="keyword">return</span> a; &#125;;</span><br><span class="line">    <span class="keyword">auto</span> f2 = [&amp;] &#123;<span class="keyword">return</span> a++; &#125;;</span><br><span class="line">    <span class="keyword">auto</span> f3 = [=] &#123;<span class="keyword">return</span> a; &#125;; </span><br><span class="line">    <span class="keyword">auto</span> f4 = [=] &#123;<span class="keyword">return</span> a++; &#125;; </span><br><span class="line">    <span class="keyword">auto</span> f5 = [a] &#123;<span class="keyword">return</span> a + b; &#125;; </span><br><span class="line">    <span class="keyword">auto</span> f6 = [a, &amp;b] &#123;<span class="keyword">return</span> a + (b++); &#125;; </span><br><span class="line">    <span class="keyword">auto</span> f7 = [=, &amp;b] &#123;<span class="keyword">return</span> a + (b++); &#125;; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><span style=color:red;background:yellow><strong>总结：</strong></span></p>
<p>对于lambda表达式，大家可能会在实际代码中见到非常多种形式，需要读懂它的意思</p>
<p>（1）lambda表达式的参数列表与普通函数的参数列表一样，如果没有参数，则参数列表可以省略不写；</p>
<p>（2）如果没有需要捕获的内容，需要写上[]；</p>
<p>（3）选项如非必需，可以省略</p>
<p>​		mutable: 可以修改按值传递进来的拷贝（注意是能修改拷贝，而不是值本身）</p>
<p>​		exception: 指定函数抛出的异常，如抛出整数类型的异常，可以使用throw();</p>
<p>（4）返回类型可以省略。通过返回值后置语法来定义的。一般情况下，不指定lambda表达式的返回值，编译器会根据return语句自动推导返回值的类型，但需要注意的是labmda表达式不能通过列表初始化自动推导出返回值类型。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ok，可以自动推导出返回值类型</span></span><br><span class="line"><span class="keyword">auto</span> f = [](<span class="type">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//error,不能推导出返回值类型</span></span><br><span class="line"><span class="keyword">auto</span> f1 = []()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> &#123;<span class="number">1</span>, <span class="number">2</span>&#125;; <span class="comment">// 基于列表初始化推导返回值，错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（5）函数体不能省略，但可以为空。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> f = []()&#123;&#125;; </span><br><span class="line">[]()&#123;&#125;(); <span class="comment">//极致省略的匿名函数调用</span></span><br></pre></td></tr></table></figure>





<h4 id="lambda表达式的返回类型"><a href="#lambda表达式的返回类型" class="headerlink" title="lambda表达式的返回类型"></a>lambda表达式的返回类型</h4><p>至此仍然存在一个问题auto推导出来的类型究竟是什么呢？</p>
<p>lambda表达式的返回类型与匿名函数的returnType并非是同一件事。</p>
<p>lambda表达式的返回类型在C++11中会被看做是一个带operator()的类，即仿函数。按照C++标准，lambda表达式的operator()默认是const的，一个const成员函数是无法修改成员变量值的。mutable选项的作用就在于取消operator()的const属性。</p>
<p>这里附上一个网站：<a target="_blank" rel="noopener" href="https://cppinsights.io/">https://cppinsights.io/</a></p>
<p>可以通过它查看编译器是如何处理代码的。</p>
<p>因为lambda表达式在C++中会被看做是一个仿函数，因此可以使用std::function和std::bind来存储和操作lambda表达式（算法适配器的使用）</p>
<p>关于这一部分，到1.4.6这一节再来进行演示说明。</p>
<h3 id="remove-if函数"><a href="#remove-if函数" class="headerlink" title="remove_if函数"></a>remove_if函数</h3><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><p>首先还是通过cpp参考文档出发</p>
<p><img src="/will-blog.github.io/./image-20250110170422501.png" alt="image-20250110170422501"></p>
<p>第三个参数p是一个一元谓词。</p>
<p>一元函数：函数的参数只有一个。二元函数：函数的参数只有两个。</p>
<p>一元断言&#x2F;谓词：函数的参数只有一个，并且返回类型是bool。二元断言&#x2F;谓词：函数的参数只有两个，并且返回类型是bool</p>
<p>根据函数的说明，能够理解它的作用，那么可以简单尝试着使用一下，如下想要移除vector中大于5的元素：</p>
<p><font color=red><strong>但是发现没有得到想要的结果</strong></font>，那么可以从源码出发来进行探索。</p>
<img src="./image-20250110170124860.png" alt="image-20250110170124860" style="zoom:67%;" />



<h4 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> ForwardIt, <span class="keyword">class</span> UnaryPredicate&gt;</span></span><br><span class="line"><span class="function">ForwardIt <span class="title">remove_if</span><span class="params">(ForwardIt first, ForwardIt last, UnaryPredicate p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    first = std::<span class="built_in">find_if</span>(first, last, p);</span><br><span class="line">    <span class="keyword">if</span> (first != last)</span><br><span class="line">        <span class="keyword">for</span>(ForwardIt i = first; ++i != last; )</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">p</span>(*i))</span><br><span class="line">                *first++ = std::<span class="built_in">move</span>(*i);</span><br><span class="line">    <span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>跳转到find_if函数查看</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> InputIt, <span class="keyword">class</span> UnaryPredicate&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> InputIt <span class="title">find_if</span><span class="params">(InputIt first, InputIt last, UnaryPredicate p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (; first != last; ++first) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">p</span>(*first)) &#123;</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> last;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//分析一下过程，其实就是找到第一个大于5的元素，返回相应迭代器</span></span><br><span class="line">                       last</span><br><span class="line"><span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">5</span></span><br><span class="line">         f</span><br></pre></td></tr></table></figure>

<p>接着往下看</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用的代码</span></span><br><span class="line"><span class="built_in">remove_if</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), func);</span><br><span class="line"><span class="comment">//first = vec.begin()</span></span><br><span class="line"><span class="comment">//last =  vec.end()</span></span><br><span class="line"><span class="comment">//p = func</span></span><br><span class="line"><span class="function">ForwardIt <span class="title">remove_if</span><span class="params">(ForwardIt first, ForwardIt last, UnaryPredicate p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    first = std::<span class="built_in">find_if</span>(first, last, p);</span><br><span class="line">    <span class="keyword">if</span> (first != last)</span><br><span class="line">        <span class="keyword">for</span>(ForwardIt i = first; ++i != last; )</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">p</span>(*i))</span><br><span class="line">                *first++ = std::<span class="built_in">move</span>(*i);</span><br><span class="line">    <span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">         f             last</span><br><span class="line"><span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">5</span></span><br><span class="line">               i</span><br><span class="line">             </span><br><span class="line">            f          last</span><br><span class="line"><span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">5</span></span><br><span class="line">               i </span><br><span class="line">             </span><br><span class="line">               f       last</span><br><span class="line"><span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">5</span></span><br><span class="line">                     i </span><br><span class="line"><span class="comment">//最终返回4这个元素对应的迭代器       </span></span><br></pre></td></tr></table></figure>

<p>还有一件有意思的事，期待的最终结果是{1,3,5,4,5}，而这样的理想结果实际上已经是vector的前五个元素了。</p>
<p>而且<font color=red><strong>remove_if函数的返回值就是待删除的元素的首迭代器。</strong></font></p>
<img src="./image-20250113112112414.png" alt="image-20250113112112414" style="zoom:67%;" />



<p><span style=color:red;background:yellow><strong>思考：</strong></span></p>
<p>为什么remove_if的设计不是直接去把满足条件的元素直接删掉呢？这样不就不需要再配合erase函数才能完成最终效果了吗？</p>
<p>——因为vector的元素被删除后，后面的元素会往前移，然而迭代器仍然往后移，就会造成遗漏某些元素没有处理。</p>
<p>那么删除元素时迭代器不往后移可以吗？</p>
<p>——对于vector可行的逻辑，但是对于list，反而是应该后移，这样算法就失去了普适性。</p>
<blockquote>
<p>思维拓展：</p>
<p>remove_if实际上最终的效果是同时做了两件事，更改了容器中特定位置的元素，并且返回了待删除元素的首迭代器。</p>
<p>在我们以往的认知中，同时干两件事总是比较容易出问题。比如多线程环境下，一个线程对某个数据进行写操作，一个线程对它进行读操作，如果不加锁的话，没法确定执行的先后，可能会出现预期之外的值。可以通过下面的例子来理解一下：</p>
<img src="./image-20250113175527651.png" alt="image-20250113175527651" style="zoom:67%;" />

<p>大家认为这样一串代码会有什么样的结果呢？运行一下，可能会大跌眼镜。</p>
<p>回顾vector迭代器失效的原理，试试该怎样解决。</p>
</blockquote>
<p>回到remove_if的使用，第三个参数是一元谓词</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">func</span><span class="params">(<span class="type">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value &gt; <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test0</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    for_each(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>(),[](<span class="type">int</span> &amp; value)&#123;</span><br><span class="line">                cout &lt;&lt; value &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">             &#125;);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> it = <span class="built_in">remove_if</span>(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>(),func);</span><br><span class="line">    vec.<span class="built_in">erase</span>(it,vec.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    for_each(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>(),[](<span class="type">int</span> &amp; value)&#123;</span><br><span class="line">                cout &lt;&lt; value &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">             &#125;);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>当然也可以用lambda表达式替代</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">5</span>&#125;;</span><br><span class="line">for_each(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>(),[](<span class="type">int</span> &amp; value)&#123;</span><br><span class="line">            cout &lt;&lt; value &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">         &#125;);</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> it = <span class="built_in">remove_if</span>(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>(),[](<span class="type">int</span> &amp; value)&#123;</span><br><span class="line">                                        <span class="keyword">return</span> value &gt; <span class="number">5</span>; </span><br><span class="line">                                        &#125;);</span><br><span class="line">vec.<span class="built_in">erase</span>(it,vec.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">for_each(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>(),[](<span class="type">int</span> &amp; value)&#123;</span><br><span class="line">            cout &lt;&lt; value &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">         &#125;);</span><br><span class="line">cout &lt;&lt; endl;</span><br></pre></td></tr></table></figure>



<p>进一步地，如果我们想要更灵活地指定删除元素的标准，比如大于4的删除、大于6的删除，那么最直观的想法会是给func函数加参数</p>
<p>但是这样一来func函数就成为了二元谓词，不能直接作为remove_if的参数了</p>
<p>可能会想到给func函数加上默认参数，试一试</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">func</span><span class="params">(<span class="type">int</span> value, <span class="type">int</span> a = <span class="number">5</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value &gt; a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果可以成功的话，应该也能删除掉大于5的元素</span></span><br><span class="line"><span class="comment">//但编译会报错</span></span><br><span class="line"><span class="keyword">auto</span> it = <span class="built_in">remove_if</span>(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>(),func); </span><br><span class="line">vec.<span class="built_in">erase</span>(it,vec.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure>

<p>实际上，可以利用算法适配器实现这一效果。</p>
<h3 id="算法适配器"><a href="#算法适配器" class="headerlink" title="算法适配器"></a>算法适配器</h3><h4 id="函数绑定器bind1st、bind2nd"><a href="#函数绑定器bind1st、bind2nd" class="headerlink" title="函数绑定器bind1st、bind2nd"></a>函数绑定器bind1st、bind2nd</h4><p>如下模板形式中，两个函数绑定器的第一个参数就是一个函数，第二个参数就是一个数字，如果F是一个二元函数(普通二元函数或者二元谓词)，我们可以绑定F的第一个参数(bind1st)或者第二个参数(bind2nd)，达到我们想要的效果(使用二元谓词的效果)</p>
<p><img src="/will-blog.github.io/./image-20240812102558858-1733126757209-110.png" alt="image-20240812102558858"></p>
<img src="./image-20250114172229681.png" alt="image-20250114172229681" style="zoom:80%;" />





<p>接收两个参数，返回比较的结果（bool值），这种行为很容易让人联想到之前学习过的std::less和std::greater</p>
<img src="./image-20250114172044458.png" alt="image-20250114172044458" style="zoom: 80%;" />



<p>那么我们可以写出这样的代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test0</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    for_each(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>(),[](<span class="type">int</span> &amp; value)&#123;</span><br><span class="line">                cout &lt;&lt; value &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">             &#125;);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> it = <span class="built_in">remove_if</span>(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>(),</span><br><span class="line">                        <span class="built_in">bind1st</span>(std::<span class="built_in">less</span>&lt;<span class="type">int</span>&gt;(),<span class="number">5</span>));  <span class="comment">//这样相当于将std::less的operator()函数的第一个参数固定为5</span></span><br><span class="line">    vec.<span class="built_in">erase</span>(it,vec.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    for_each(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>(),[](<span class="type">int</span> &amp; value)&#123;</span><br><span class="line">                cout &lt;&lt; value &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">             &#125;);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>—— 那么这样做的结果是删除所有大于5的元素还是所有小于5的元素呢？</p>
<p>—— 还可以利用上bind2nd（固定第二个参数），以及std::greater（其底层的operator()函数逻辑不同），分别试试搭配使用的效果并分析</p>
<h4 id="bind（非常重要）"><a href="#bind（非常重要）" class="headerlink" title="bind（非常重要）"></a>bind（非常重要）</h4><p>bind1st、bind2nd适用于二元函数，那么如果函数的参数更多呢？实际上有一个更通用的手段，就是bind</p>
<img src="./image-20240812110817465-1733126757209-116.png" alt="image-20240812110817465" style="zoom:80%;" />

<img src="./image-20250114180053729.png" alt="image-20250114180053729" style="zoom:67%;" />



<h5 id="基本使用-1"><a href="#基本使用-1" class="headerlink" title="基本使用"></a>基本使用</h5><p>如下，bind可以绑定N元函数，并用统一的方式进行使用。</p>
<img src="./image-20250114181459086.png" alt="image-20250114181459086" style="zoom:67%;" />

<p>根据cpp参考文档的解释，第一个参数可以是函数对象、函数指针、函数引用(比较少见)、指向成员函数指针或指向数据成员指针。如上将函数名直接作为参数，相当于是传入函数指针。其他的几种情况也可以试试：</p>
<p>函数对象</p>
<img src="./image-20250115144417723.png" alt="image-20250115144417723" style="zoom:67%;" />



<p>函数引用</p>
<img src="./image-20250115144332359.png" alt="image-20250115144332359" style="zoom:67%;" />



<p>成员函数指针稍稍复杂</p>
<img src="./image-20250115144930383.png" alt="image-20250115144930383" style="zoom:67%;" />



<p>指向数据成员的指针（当然这种写法比较奇特，仅作了解）</p>
<img src="./image-20250115145044752.png" alt="image-20250115145044752" style="zoom:67%;" />

<p>用这种方式访问Example类的成员还有一个前提 —— 这些成员都是public权限的。</p>
<h5 id="引用折叠"><a href="#引用折叠" class="headerlink" title="引用折叠"></a>引用折叠</h5><p>看回bind的声明形式，第一个参数看起来是一个右值引用，为什么在真正使用过程中，传入一些左值也可以呢？</p>
<p>这涉及到模板中的引用折叠</p>
<p>如下代码修改成模板后是可以正常运行的：</p>
<img src="./image-20250115152358590.png" alt="image-20250115152358590" style="zoom:67%;" />



<p>在调用func时，如果传入的实参是左值，那么T会被推导成左值引用；如果实参是右值，那么T会被推导成右值引用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(T &amp;&amp;a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">func</span>(<span class="number">10</span>);<span class="comment">//T = int &amp;&amp;</span></span><br><span class="line"><span class="built_in">func</span>(a);<span class="comment">// T = int &amp;</span></span><br></pre></td></tr></table></figure>



<p>模板中a为T&amp;&amp;类型，那么会造成多个引用符号写到一起。我们自己在写代码时不能将两个以上的引用符号写到一起，但是模板推导时会遵循一套引用折叠的机制</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//T &amp;&amp;有两种情况</span></span><br><span class="line">&amp; &amp;&amp;----&gt;&amp;</span><br><span class="line">&amp;&amp; &amp;&amp;----&gt;&amp;&amp;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果模板的函数参数为T&amp;形式</span></span><br><span class="line"><span class="comment">//也有两种情况</span></span><br><span class="line">&amp; &amp; ----&gt;&amp;</span><br><span class="line">&amp;&amp; &amp;-----&gt;&amp;</span><br></pre></td></tr></table></figure>

<p>根据上面的引用折叠规则可知，模板中写成T&amp;&amp;，实参既可以传左值，也可以传右值；如果模板中写成了T&amp;，那么实参就只能传左值。</p>
<h5 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h5><p>接下来需要思考的一个问题是，上面的bind函数调用的返回值究竟是什么，我们每次都使用了auto关键字，那么auto究竟推导出什么类型？</p>
<p>看到某一个变量后加上括号，起到调用函数的作用，应该会联想到以前学习过的函数指针。</p>
<p>假设有相同类型的函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">20</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>func和func2的返回类型与参数情况一致，可以使用同种函数指针进行调用。为了方便使用，可以给这种函数指针类型起别名。</p>
<p>函数指针被初始化为函数的地址(函数指针指向函数)相当于是函数的注册；</p>
<p>使用函数指针调用函数时才会执行函数。</p>
<p>这就对应了一种延迟调用的思想（先注册，后执行），可以用来作回调函数。与之理念相似的还有C++的多态思想：基类指针调用虚函数时，只有到运行时（根据基类指针究竟指向的是哪个派生类对象）才能确定具体执行哪个虚函数。</p>
<p><img src="/will-blog.github.io/./image-20240812113718833-1733126757209-115.png" alt="image-20240812113718833"></p>
<h5 id="占位符"><a href="#占位符" class="headerlink" title="占位符"></a>占位符</h5><p>回到bind的基本使用，似乎每次都需要将被绑定的函数的所有参数都一起传入。</p>
<p>除此之外，还有一种占位符的写法。</p>
<p><img src="/will-blog.github.io/./image-20250116152316060.png" alt="image-20250116152316060"></p>
<p>还可以进一步地：</p>
<img src="./image-20250116165041225.png" alt="image-20250116165041225" style="zoom:67%;" />



<blockquote>
<p>这里的使用实际上非常容易出错，看看更多参数的情况：</p>
<img src="./image-20250116173910192.png" alt="image-20250116173910192" style="zoom:67%;" />



<p>这样写自然没有问题</p>
<img src="./image-20250116170139188.png" alt="image-20250116170139188" style="zoom:67%;" />



<p>如果将占位符改换一下，却会出错</p>
<img src="./image-20250116170903860.png" alt="image-20250116170903860" style="zoom:67%;" />

<p><strong>也就是说使用了_4这个占位符，那么在传入实参时至少要传入4个参数。（f调用时可以传很多个参数，多余的参数被舍弃）</strong></p>
<p>对于func函数，第一个参数是传入的10，第二个参数是占位符匹配到的20，第三个参数是占位符匹配到的400，第四个和第五个则是传入的number</p>
<p><span style=color:red;background:yellow><strong>可以理解为占位符整体代表的是形参的位置，占位符中的数字代表的是实参的位置。</strong></span></p>
</blockquote>
<p>—— 再看一个有意思的事情</p>
<img src="./image-20250116172739413.png" alt="image-20250116172739413" style="zoom:67%;" />

<p><strong>说明了bind的默认传递方式是值传递</strong>，如果在bind中想要使用引用传递，需要用到引用包装器。</p>
<img src="./image-20250116175032813.png" alt="image-20250116175032813" style="zoom:67%;" />

<p>如上在bind传参时使用<font color=red><strong>引用包装器std::ref</strong></font> (reference)</p>
<p>如果func函数中原本形参形式为const引用，相应地可以使用<font color=red><strong>常引用包装器std::cref</strong></font> (const reference)</p>
<img src="./image-20250116175501510.png" alt="image-20250116175501510" style="zoom: 67%;" />





<h4 id="function的使用"><a href="#function的使用" class="headerlink" title="function的使用"></a>function的使用</h4><p>再研究一下bind函数的返回值问题</p>
<p>对于函数而言，函数的类型包含了两个信息：函数返回类型 + 函数参数列表（包含了函数参数的类型、个数、顺序）</p>
<img src="./image-20250117100409588.png" alt="image-20250117100409588" style="zoom:67%;" />



<p>很多时候，逻辑层面上很好理解，但是原生的语法却并不支持这种表达，STL则提供了一种方式可以支持这种表达。</p>
<img src="./image-20240812145418894-1733126757209-119.png" alt="image-20240812145418894" style="zoom:67%;" />

<p><img src="/will-blog.github.io/./image-20250117103618406.png" alt="image-20250117103618406"></p>
<p><strong>体现了万物皆对象的思想</strong></p>
<img src="./image-20250117104001027.png" alt="image-20250117104001027" style="zoom:67%;" />



<p>同理，逻辑类型应该为int(int)时，可以写成：</p>
<img src="./image-20250117104615584.png" alt="image-20250117104615584" style="zoom:67%;" />





<h5 id="绑定成员函数的传参"><a href="#绑定成员函数的传参" class="headerlink" title="绑定成员函数的传参"></a>绑定成员函数的传参</h5><p>对于bind绑定成员函数的结果，也是一样的形式，非常简单</p>
<img src="./image-20250117105554463.png" alt="image-20250117105554463" style="zoom:67%;" />



<p>如果结合占位符，其形式就更加多种多样了</p>
<img src="./image-20250117114418119.png" alt="image-20250117114418119" style="zoom:67%;" />

<p><font color=red><strong>当然，自己写代码的时候不建议写成这种带”炮灰”的形式，没有必要，还很容易混淆。</strong></font></p>
<p>总结：</p>
<p><span style=color:red;background:yellow><strong>function称为函数包装器，其存储的是函数类型，所以也可以称为函数容器。</strong></span></p>
<h5 id="function表示lambda表达式返回值"><a href="#function表示lambda表达式返回值" class="headerlink" title="function表示lambda表达式返回值"></a>function表示lambda表达式返回值</h5><p>在1.4.4这一节有一个遗留的问题，lambda表达式的返回值是什么？</p>
<p>我们可以利用std::function进行相应的表示</p>
<p><img src="/will-blog.github.io/./image-20240812151459260-1733126757209-112.png" alt="image-20240812151459260"></p>
<h5 id="function使用的误区"><a href="#function使用的误区" class="headerlink" title="function使用的误区"></a>function使用的误区</h5><p>在使用std::function管理lambda表达式时还有一种使用的误区<font color=red><strong>（大坑）</strong></font></p>
<p><img src="/will-blog.github.io/./image-20240812152701250-1733126757209-109.png" alt="image-20240812152701250"></p>
<p><span style=color:red;background:yellow><strong>不要捕获局部变量的引用</strong></span></p>
<blockquote>
<p>回到funcion接收binf返回值的例子，当bind函数绑定类的成员函数时，需要传入对象的地址以对应this指针这个参数，实际上还有一种写法</p>
<p><img src="/will-blog.github.io/./image-20240812155206272-1733126757209-121.png" alt="image-20240812155206272"></p>
<p>bind绑定成员函数的时候，有两种传递的方式，<strong>第一种：直接传递对象的地址，第二种，将对象拷贝进来。</strong></p>
<p>—— 如果使用的是第一种，那么会传递的是地址值，那么就只会有一个指针大小的开销；但是如果是传递对象，就会拷贝对象，如果对象占据的空间比较大，那么开销也会比较大。</p>
<p>那传递对象的写法有什么意义呢？</p>
<p>—— 如果使用的是第一种，传递的是地址值，如果对象本身已经销毁了，那么有可能会有空指针的情况。</p>
<p>比如对象ex的创建是A线程，bind的绑定是B线程，在bind绑定时传对象的地址值，但A线程已经销毁了，就会出现这样的问题。</p>
<p>但是如果使用第二种形式，传递的是对象，那么就不会出现空指针的问题。</p>
<p><span style=color:red;background:yellow><strong>所以在多线程环境下，更建议传对象，而不是传地址。</strong></span></p>
</blockquote>
<h4 id="bind与function的结合使用（重要）"><a href="#bind与function的结合使用（重要）" class="headerlink" title="bind与function的结合使用（重要）"></a>bind与function的结合使用（重要）</h4><p>我们了解了std::bind和std::function各自的基本使用，再来看看它们的结合使用，这是一种<strong>非常非常非常</strong>强大的用法，因为bind具备改变函数形态的功能，只要函数的返回类型相同，任何参数类型的函数都可以被bind绑定之后，变成函数类型完全一致的函数类型，然后都可以被function进行接收。</p>
<p>来看一个std::function与std::bind结合使用体现出多态性的例子，也就是注册回调函数与执行回调函数。</p>
<p>在学习多态时，我们学过一段计算图形面积的例子</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Figure</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> string <span class="title">getName</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">getArea</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">(Figure &amp; fig)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; fig.<span class="built_in">getName</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;的面积：&quot;</span>;</span><br><span class="line">    cout &lt;&lt; fig.<span class="built_in">getArea</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span></span><br><span class="line">: <span class="keyword">public</span> Figure</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Rectangle</span>(<span class="type">double</span> len,<span class="type">double</span> wid)</span><br><span class="line">    : _length(len)</span><br><span class="line">    , _width(wid)</span><br><span class="line">    &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">getName</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;矩形&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">getArea</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _length * _width;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> _length;</span><br><span class="line">    <span class="type">double</span> _width;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test0</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Rectangle <span class="title">rt</span><span class="params">(<span class="number">2</span>,<span class="number">5</span>)</span></span>;</span><br><span class="line">    <span class="built_in">display</span>(rt);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="built_in">test0</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>







<p><img src="/will-blog.github.io/./image-20240812180635362-1733126757209-122.png" alt="image-20240812180635362"></p>
<p><img src="/will-blog.github.io/./image-20240812180713368-1733126757209-124.png" alt="image-20240812180713368"></p>
<p><img src="/will-blog.github.io/./image-20240812180817369-1733126757209-123.png" alt="image-20240812180817369"></p>
<p>面相对象的写法：继承 + 纯虚函数(或者普通的虚函数)，具有一定的局限性：必须建立继承关系，派生类对基类的虚函数进行覆盖时必须要函数名和函数形式完全一致等；</p>
<p>基于对象的写法：std::function + std::bind，这一套写法摒弃了上述的局限性，同样体现出多态性且更灵活。</p>
<h3 id="mem-fn成员函数适配器"><a href="#mem-fn成员函数适配器" class="headerlink" title="mem_fn成员函数适配器"></a>mem_fn成员函数适配器</h3><p>因为成员函数与算法库中的算法不能直接很好的适配，所以二者结合使用的时候，需要使用成员函数适配器进行适配。</p>
<img src="./image-20250121151937130.png" alt="image-20250121151937130" style="zoom:67%;" />



<p>使用成员函数适配器mem_fn进行简单的包装即可</p>
<p><img src="/will-blog.github.io/./image-20250121150627602.png" alt="image-20250121150627602"></p>
<p>完成遍历后可以顺带回顾一下remove_if的使用</p>
<img src="./image-20250121152520023.png" alt="image-20250121152520023" style="zoom:67%;" />

<img src="./image-20250121152629153.png" alt="image-20250121152629153" style="zoom:67%;" />



<p>——思考：上述例子中使用for_each遍历vector时，使用了mem_fn为成员函数print做适配。根据以前学过的知识，还有没有什么方法实现同样效果呢？</p>
<p>for_each的第三个参数要求是一个一元函数，成员函数print看起来无参，实际上有隐含的this指针作为参数，它的确是一个一元函数。</p>
<img src="./image-20250121162733638.png" alt="image-20250121162733638" style="zoom:67%;" />



<p>或者我们也可以用function接一下bind绑定成员函数的结果</p>
<p><img src="/will-blog.github.io/./image-20250121164540811.png" alt="image-20250121164540811"></p>
<h2 id="适配器"><a href="#适配器" class="headerlink" title="适配器"></a>适配器</h2><p>适配器就是Interface(接口)，对容器、迭代器和算法进行包装，但其实质还是容器、迭代器和算法，只是不依赖于具体的标准容器、迭代器和算法类型，容器适配器可以理解为容器的模板，迭代器适配器可理解为迭代器的模板，算法适配器可理解为算法的模板。</p>
<h2 id="函数对象"><a href="#函数对象" class="headerlink" title="函数对象"></a>函数对象</h2><p>也可以称为仿函数。只要可以与小括号进行结合展示出函数含义都可以称为函数对象。</p>
<ul>
<li>重载了函数调用运算符的类创建的对象。</li>
<li>函数指针</li>
<li>function</li>
<li>函数名</li>
</ul>
<h2 id="空间配置器（重难点）"><a href="#空间配置器（重难点）" class="headerlink" title="空间配置器（重难点）"></a>空间配置器（重难点）</h2><p>在C++中所有STL容器的空间分配其实都是使用的std::allocator</p>
<p>std::allocator可以感知类型的空间分配器，将空间的申请与对象的构建、以及空间的回收与对象的销毁严格分离。</p>
<p>以前我们知道使用new创建单个对象的时候，空间的申请与对象的构造实际也是分开的（可以回顾new表达式的工作步骤）。</p>
<blockquote>
<p>那么为什么要将空间的申请与对象的构建分开呢？</p>
<p>(1) <strong>减少不必要的对象构造和析构</strong>：在容器的使用过程中，有时只是需要预留一些空间，而并不需要立即在这些空间上构造对象。例如，std::vector 的 reserve 函数，它的作用是为容器预留足够的内存空间，但不会构造任何对象。如果不将空间申请和对象构建分开，每次预留空间时都会构造对象，之后又可能因为不需要这些对象而进行析构，这会带来不必要的性能开销。</p>
<p>(2)<strong>方便实现复杂的容器操作</strong>：在实现容器的一些操作，如插入、删除元素时，将空间申请和对象构建分开可以更方便地处理各种情况。例如，在插入元素时，如果当前空间不足，容器可以先申请新的空间，然后将原有元素移动到新空间，最后在合适的位置构造新的对象，这样的操作更加灵活和高效。（比如vector的动态扩容机制背后就使用了空间配置器）</p>
</blockquote>
<h3 id="函数使用"><a href="#函数使用" class="headerlink" title="函数使用"></a>函数使用</h3><p>std::allocator最重要的成员函数：</p>
<img src="./image-20250124102502538.png" alt="image-20250124102502538" style="zoom:67%;" />



<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//申请空间</span></span><br><span class="line"><span class="function">T* <span class="title">allocate</span><span class="params">( std::<span class="type">size_t</span> n )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放空间</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">deallocate</span><span class="params">( T* p, std::<span class="type">size_t</span> n )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构建对象</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">construct</span><span class="params">( pointer p, const_reference val )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁对象</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">destroy</span><span class="params">( pointer p )</span></span>;</span><br></pre></td></tr></table></figure>





<p>来尝试完成一个任务，实现自定义的vector，首先给出如下的代码接口</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyVector</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyVector</span>();</span><br><span class="line">    ~<span class="built_in">MyVector</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">const</span> T &amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop_back</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">capacity</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//重新分配内存，动态扩容要用的</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reallocate</span><span class="params">()</span></span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">//空间的申请与对象的构建分开</span></span><br><span class="line">    <span class="type">static</span> std::allocator&lt;T&gt; _alloc;</span><br><span class="line"></span><br><span class="line">    T * _start;</span><br><span class="line">    T * _finish;</span><br><span class="line">    T * _end_of_storage;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>（1）先完成比较简单的</p>
<img src="./image-20250124103233188.png" alt="image-20250124103233188" style="zoom:67%;" />



<p>（2）尾部插入元素、删除元素，模拟vector的核心问题就是动态扩容</p>
<img src="./image-20250124103731526.png" alt="image-20250124103731526" style="zoom:67%;" />



<p>（3）完成动态扩容的功能</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> MyVector&lt;T&gt;::<span class="built_in">reallocate</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//1.申请两倍的新的空间</span></span><br><span class="line">    <span class="type">int</span> oldCapacity = <span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> newCapacity = <span class="number">2</span> * oldCapacity &gt; <span class="number">0</span> ? <span class="number">2</span> * oldCapacity : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    T * ptmp = _alloc.<span class="built_in">allocate</span>(newCapacity);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(_start)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//2.使用算法库的函数将老的空间上的元素拷贝到新的空间</span></span><br><span class="line">        std::<span class="built_in">uninitialized_copy</span>(_start,_finish,ptmp);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.老的空间上的元素需要销毁，</span></span><br><span class="line">        <span class="comment">//同时老的空间也要回收</span></span><br><span class="line">        <span class="keyword">while</span>(_start != _finish)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* _alloc.destroy(_start++); */</span></span><br><span class="line">            <span class="comment">//注意一下边界问题，这样写是完善的</span></span><br><span class="line">            _alloc.<span class="built_in">destroy</span>(--_finish);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//参数为指针(T*)和偏移量(size_t)</span></span><br><span class="line">        <span class="comment">//如果从_finish开始，偏移量为负数，而size_t不好表达</span></span><br><span class="line">        <span class="comment">//如果从_start开始,偏移量为正数，更方便</span></span><br><span class="line">        <span class="comment">//所以选择_start固定，移动_finish;</span></span><br><span class="line">        _alloc.<span class="built_in">deallocate</span>(_start,oldCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.三个指针与新的空间之间产生联系</span></span><br><span class="line">    _start = ptmp;</span><br><span class="line">    _finish = ptmp + oldCapacity;</span><br><span class="line">    _end_of_storage = ptmp + newCapacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>析构函数的逻辑类似，也是销毁元素、回收空间</p>
<img src="./image-20250124104636381.png" alt="image-20250124104636381" style="zoom:67%;" />



<p>(4)测试效果</p>
<img src="./image-20250124105021706.png" alt="image-20250124105021706" style="zoom:67%;" />



<p>如果想遍历容器中的元素，首先想到的肯定是增强for循环方式（没有实现取下标，也没有实现迭代器相关的函数）</p>
<p>但仍然出现错误，说明增强for循环的底层实际上也是通过迭代器实现的</p>
<p><img src="/will-blog.github.io/./image-20250124105645274.png" alt="image-20250124105645274"></p>
<p>（5）完成迭代器相关函数</p>
<img src="./image-20250124110222143.png" alt="image-20250124110222143" style="zoom:67%;" />

<p>测试</p>
<img src="./image-20250124110309969.png" alt="image-20250124110309969" style="zoom:67%;" />



<p>完成了简单的模拟后，其实还有很多可以完善的地方，比如取下标、比如insert，可以自行完善。</p>
<p>本章主要借此展示了alloctor空间配置器的基本使用，当然想要进一步了解它，还是需要阅读源码。</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>空间配置器会分为两级：</p>
<p>一级空间配置器使用类模板malloc_alloc_template ，其底层使用的是malloc&#x2F;free进行空间的申请与释放；</p>
<p>二级空间配置器使用类模板default_alloc_template（默认空间配置器），其底层根据申请空间大小又分为两个分支，第一分支是当申请的空间大于128字节的时候，还是走malloc_alloc_template ，当申请的空间小于128字节的使用，使用内存池 + 自由链表的方法申请空间。</p>
<p><span style=color:red;background:yellow><strong>注意：这里提到的自由链表实际是一个容量为16的指针数组，在源码中使用了_S_free_list这个名字，直译为自由链表</strong></span></p>
<p>有一个容量为16的指针数组，每个元素（指针）指向一个链表 ，用于管理不同大小的内存块。这 16 个指针所指向的链表，分别对应 8、16、24、32、40、48、52、64、72、80、88、96、104、112、120、128 字节的内存块。</p>
<p>每当程序申请小于 128 字节的内存时，二级空间配置器会先将申请的内存大小上调为 8 的倍数，再根据上调后的大小（8的整数倍）找到对应的链表。</p>
<blockquote>
<p>比如：</p>
<p>数组中下标为3的指针，代表着会按照8 * (3 + 1) &#x3D; 32字节为基本单位申请空间。</p>
<p>第一次申请32个字节空间的时候，一次性申请很大一片空间（比如32 * 20 &#x3D; 640个字节），然后按照32字节为一个等分，分成多个等分，然后挂接在下标为3的指针下面，形成链表形式。</p>
<p>以后需要32字节的时候，直接在下标为3的下面取出一个节点即可，就是32个字节的内存空间。</p>
<p>如果申请64字节空间，第一次申请时也申请很大一片空间，同样按照64字节为一个等分，分成多个等分，挂载在数组中下标为7的指针之下。</p>
<p>以后如果需要申请64字节时，就在下标为7的下面取出一个节点即可。</p>
<p>其他下标的处理方式完全一致。</p>
</blockquote>
<p>自由链表的工作示意图如下</p>
<p>第一次申请空间时比较麻烦，后续再此申请同等大小的空间可以以O(1)的时间复杂度完成申请。</p>
<p><img src="/will-blog.github.io/./image-20240813115402461-1733127460324-147.png" alt="image-20240813115402461"></p>
<p>—— 这么干有什么意义呢，为什么不每次直接申请相应大小的空间？</p>
<p>如果频繁申请小片空间，可能会出现内存碎片的问题，这样导致空间的利用率低；</p>
<p> 会在内核态与用户态之间进行频繁的切换，时间消耗也比较大。</p>
<h3 id="源码-1"><a href="#源码-1" class="headerlink" title="源码"></a>源码</h3><p>在cpp参考文档中，任意从一个容器出发找到空间配置器</p>
<img src="./image-20250320152347327.png" alt="image-20250320152347327" style="zoom:67%;" />

<p>由头文件<code>&lt;memory&gt; </code>找到<code>&lt;stl_alloc.h&gt;</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">allocator</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="comment">//了解到_Alloc类型别名</span></span><br><span class="line">    <span class="keyword">typedef</span> alloc _Alloc;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">_Tp* <span class="title">allocate</span><span class="params">(size_type __n, <span class="type">const</span> <span class="type">void</span>* = <span class="number">0</span>)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//如果申请空间大小不为0，调用_Alloc的静态成员函数allocate</span></span><br><span class="line">         <span class="comment">//如果申请空间大小为0，返回空指针</span></span><br><span class="line">        <span class="keyword">return</span> __n != <span class="number">0</span> ? <span class="built_in">static_cast</span>&lt;_Tp*&gt;(_Alloc::<span class="built_in">allocate</span>(__n * <span class="built_in">sizeof</span>(_Tp))) : <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deallocate</span><span class="params">(pointer __p, size_type __n)</span></span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        _Alloc::<span class="built_in">deallocate</span>(__p, __n * <span class="built_in">sizeof</span>(_Tp)); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">construct</span><span class="params">(pointer __p, <span class="type">const</span> _Tp&amp; __val)</span> </span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">new</span>(__p) _Tp(__val); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">destroy</span><span class="params">(pointer __p)</span> </span></span><br><span class="line"><span class="function">    </span>&#123; __p-&gt;~_Tp(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>继续查看类型别名原本的定义</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> malloc_alloc alloc;</span><br><span class="line"><span class="keyword">typedef</span> __malloc_alloc_template&lt;<span class="number">0</span>&gt; malloc_alloc;</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> __inst&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">__malloc_alloc_template</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="title">allocate</span><span class="params">(<span class="type">size_t</span> __n)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="comment">//其实底层就是使用了malloc</span></span><br><span class="line">    <span class="type">void</span>* __result = <span class="built_in">malloc</span>(__n);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">nullptr</span> == __result)</span><br><span class="line">        __result = _S_oom_malloc(__n); <span class="comment">//申请失败的情况</span></span><br><span class="line">    <span class="keyword">return</span> __result; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><span style=color:red;background:yellow><strong>这就是一级空间配置器</strong></span></p>
<p>回到typedef alloc _Alloc; 查找alloc时还有第二个分支</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//另一个分支的alloc类</span></span><br><span class="line"><span class="keyword">typedef</span> __default_alloc_template&lt;__NODE_ALLOCATOR_THREADS, <span class="number">0</span>&gt; alloc;</span><br><span class="line"></span><br><span class="line"><span class="comment">//相当于</span></span><br><span class="line"><span class="meta"># <span class="keyword">ifdef</span> __USE_MALLOC</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> malloc_alloc alloc;</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">else</span></span></span><br><span class="line"><span class="keyword">typedef</span> __default_alloc_template&lt;__NODE_ALLOCATOR_THREADS, <span class="number">0</span>&gt; alloc;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>



<p>查看__default_alloc_template的定义(下面对源码进行了一定的简化)</p>
<p><span style=color:red;background:yellow><strong>也就是二级空间配置器</strong></span></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//主要查看静态成员函数allocate的定义</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> threads, <span class="type">int</span> inst&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">__default_alloc_template</span> &#123;</span><br><span class="line">    <span class="keyword">enum</span> &#123;_ALIGN = <span class="number">8</span>&#125;;</span><br><span class="line">    <span class="keyword">enum</span> &#123;_MAX_BYTES = <span class="number">128</span>&#125;;</span><br><span class="line">    <span class="keyword">enum</span> &#123;_NFREELISTS = <span class="number">16</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">     <span class="comment">/* __n must be &gt; 0      */</span></span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="title">allocate</span><span class="params">(<span class="type">size_t</span> __n)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="type">void</span>* __ret = <span class="number">0</span>;</span><br><span class="line">      </span><br><span class="line">    <span class="keyword">if</span> (__n &gt; <span class="number">128</span>) &#123;   <span class="comment">// if (__n &gt; (size_t) _MAX_BYTES)&#123;</span></span><br><span class="line">        <span class="comment">//__ret = malloc_alloc::allocate(__n);</span></span><br><span class="line">        <span class="comment">//又回到刚才的情况了，等价于就是调用了malloc</span></span><br><span class="line">        __ret = <span class="built_in">malloc</span>(__n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//这一步很关键，跳转查看_S_free_list和_S_freelist_index</span></span><br><span class="line">        <span class="comment">//从数组开始位置偏移相应长度，接下来可以在这个位置之下挂载内存块节点</span></span><br><span class="line">      _Obj** __my_free_list = _S_free_list + _S_freelist_index(__n);  </span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">      _Obj* __RESTRICT __result = *__my_free_list;</span><br><span class="line">      <span class="keyword">if</span> (__result == <span class="number">0</span>)</span><br><span class="line">        __ret = _S_refill(_S_round_up(__n));</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        *__my_free_list = __result -&gt; _M_free_list_link;</span><br><span class="line">        __ret = __result;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> __ret;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>对于<code>_S_free_list</code>，最终其类型为<code>_obj*[16]</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">if</span> defined(__SUNPRO_CC) || defined(__GNUC__) || defined(__HP_aCC)</span></span><br><span class="line">    <span class="type">static</span> _Obj*  _S_free_list[]; </span><br><span class="line">        <span class="comment">// Specifying a size results in duplicate def for 4.1</span></span><br><span class="line"><span class="meta"># <span class="keyword">else</span></span></span><br><span class="line">    <span class="type">static</span> _Obj*  _S_free_list[<span class="number">16</span>]; </span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> __threads, <span class="type">int</span> __inst&gt;</span><br><span class="line"><span class="keyword">typename</span> __default_alloc_template&lt;__threads, __inst&gt;::_Obj* __STL_VOLATILE</span><br><span class="line">__default_alloc_template&lt;__threads, __inst&gt; ::_S_free_list[</span><br><span class="line"><span class="meta"># <span class="keyword">if</span> defined(__SUNPRO_CC) || defined(__GNUC__) || defined(__HP_aCC)</span></span><br><span class="line">    _NFREELISTS</span><br><span class="line"><span class="meta"># <span class="keyword">else</span></span></span><br><span class="line">    __default_alloc_template&lt;__threads, __inst&gt;::_NFREELISTS</span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line">] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, &#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>对于<code>_S_freelist_index(__n)</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//假设申请32字节，这里传入的参数就是32</span></span><br><span class="line"><span class="type">static</span> <span class="type">size_t</span> _S_freelist_index(<span class="type">size_t</span> __bytes) &#123;</span><br><span class="line">    <span class="comment">//(32 + 8 - 1)/8 - 1 = 4 - 1 = 3       32字节对应数组中下标为3的位置</span></span><br><span class="line">    <span class="keyword">return</span> (((__bytes) + (<span class="type">size_t</span>)_ALIGN<span class="number">-1</span>)/(<span class="type">size_t</span>)_ALIGN - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><span style=color:red;background:yellow><strong>作用：根据申请内存的大小取其对应于指针数组（自由链表）中的下标</strong></span></p>
<p>刚才的allocate函数中申请空间大小小于128的分支就可以这样来进行理解</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">//假设申请32字节，__n = 32</span></span><br><span class="line">  <span class="comment">//_S_freelist_index(32) = 3</span></span><br><span class="line">  <span class="comment">//类似于int* arr[16] = &#123;0&#125;;</span></span><br><span class="line">  <span class="comment">//int **p = arr + 3;</span></span><br><span class="line">_Obj** __my_free_list = _S_free_list + _S_freelist_index(__n);  </span><br><span class="line"> </span><br><span class="line">  <span class="comment">//一开始_S_free_list里存的全都是空指针</span></span><br><span class="line">  <span class="comment">//__result = nullptr;</span></span><br><span class="line">_Obj* __RESTRICT __result = *__my_free_list;</span><br><span class="line"><span class="keyword">if</span> (__result == <span class="literal">nullptr</span>) </span><br><span class="line">  __ret = _S_refill(_S_round_up(__n));  <span class="comment">//跳转查看_S_round_up，再跳转查看_S_refill</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">  *__my_free_list = __result -&gt; _M_free_list_link;</span><br><span class="line">  __ret = __result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>_S_round_up函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">size_t</span> _S_round_up(<span class="type">size_t</span> __bytes)  <span class="comment">//__bytes = 32</span></span><br><span class="line">&#123; </span><br><span class="line">    <span class="comment">//(32 + 8 - 1) &amp; ~(8 - 1) = 39 &amp; ~7  按位与</span></span><br><span class="line">    <span class="comment">//39 = 32 + 4 + 2 + 1 ====&gt; 0010 0111</span></span><br><span class="line">    <span class="comment">//7 = 4 + 2 + 1 ====&gt; 0000 0111  再取反 ~7 = 1111 1000</span></span><br><span class="line">    <span class="comment">//39 &amp; ~7 = 0010 0000  =====&gt; 就是32</span></span><br><span class="line">    <span class="keyword">return</span> (((__bytes) + (<span class="type">size_t</span>) _ALIGN<span class="number">-1</span>) &amp; ~((<span class="type">size_t</span>) _ALIGN - <span class="number">1</span>)); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//传入的参数是32，返回值也是32，好像有点没必要，那么试试如果传进来的是31</span></span><br><span class="line">    <span class="comment">//(31 + 8 - 1) &amp; ~(8 - 1) = 38 &amp; ~7  按位与</span></span><br><span class="line">    <span class="comment">//38 = 32 + 4 + 2 ====&gt; 0010 0110</span></span><br><span class="line">    <span class="comment">//7 = 4 + 2 + 1 ====&gt; 0000 0111  再取反 ~7 = 1111 1000</span></span><br><span class="line">    <span class="comment">//38 &amp; ~7 = 0010 0000  =====&gt; 也是32</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果传入的是33</span></span><br><span class="line">    <span class="comment">//(33 + 8 - 1) &amp; ~(8 - 1) = 40 &amp; ~7  按位与</span></span><br><span class="line">    <span class="comment">//40 = 32 + 8 ====&gt; 0010 1000</span></span><br><span class="line">    <span class="comment">//7 = 4 + 2 + 1 ====&gt; 0000 0111  再取反 ~7 = 1111 1000</span></span><br><span class="line">    <span class="comment">//40 &amp; ~7 = 0010 1000  =====&gt; 40</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//不妨多试一下参数</span></span><br><span class="line">    <span class="comment">//25 ---&gt; 32</span></span><br><span class="line">    <span class="comment">//24 ---&gt; 24</span></span><br><span class="line">    <span class="comment">//...</span></span><br></pre></td></tr></table></figure>

<p><span style=color:red;background:yellow><strong>作用：这个函数实现的就是向上取整得到8的整数倍</strong></span></p>
<p>_S_refill函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//仍然根据刚才的假设走，此时传入参数__n = 32</span></span><br><span class="line"><span class="type">void</span>* __default_alloc_template&lt;__threads, __inst&gt;::_S_refill(<span class="type">size_t</span> __n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> __nobjs = <span class="number">20</span>;</span><br><span class="line">    <span class="comment">//_S_chunk_alloc实际申请了2 * 20 * 32 = 1280字节空间</span></span><br><span class="line">    <span class="comment">//__chunk会指向前640字节的空间的首地址</span></span><br><span class="line">    <span class="type">char</span>* __chunk = _S_chunk_alloc(__n, __nobjs); <span class="comment">//_S_chunk_alloc这个函数才是真正去申请了空间的函数，大家可以先自行查看源码理解这个函数的执行过程</span></span><br><span class="line">    </span><br><span class="line">    _Obj* __STL_VOLATILE* __my_free_list;</span><br><span class="line">    _Obj* __result;</span><br><span class="line">    _Obj* __current_obj;</span><br><span class="line">    _Obj* __next_obj;</span><br><span class="line">    <span class="type">int</span> __i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1</span> == __nobjs) <span class="keyword">return</span>(__chunk);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//在数组中偏移到下标3位置，接下来32字节的内存块都挂载到这个位置之下</span></span><br><span class="line">    __my_free_list = _S_free_list + _S_freelist_index(__n);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Build free list in chunk */</span></span><br><span class="line">      __result = (_Obj*)__chunk;   <span class="comment">//指向640个字节的最开始，强转成_Obj*类型指针，并且__result作为了最后的返回值，实际上就是把32字节的空间交出来了</span></span><br><span class="line">      *__my_free_list = __next_obj = (_Obj*)(__chunk + __n); <span class="comment">//从640字节内存首地址偏移32字节，强转成_Obj*类型指针，并用数组中的第四个指针（下标3）进行指向</span></span><br><span class="line">      <span class="keyword">for</span> (__i = <span class="number">1</span>; ; __i++) &#123;</span><br><span class="line">        __current_obj = __next_obj;</span><br><span class="line">        __next_obj = (_Obj*)((<span class="type">char</span>*)__next_obj + __n); <span class="comment">//__next_obj再偏移32字节</span></span><br><span class="line">        <span class="keyword">if</span> (__nobjs - <span class="number">1</span> == __i) &#123; <span class="comment">//20 - 1 != 1，走else分支 —— 要循环19次，最终把剩下的19 * 32字节切割成32字节等分，一步一步挂载起来</span></span><br><span class="line">            __current_obj -&gt; _M_free_list_link = <span class="number">0</span>; </span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            __current_obj -&gt; _M_free_list_link = __next_obj;  <span class="comment">//用链表连接的方式，从（640-32）剩下的内存块中又切割出32字节</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">return</span>(__result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><span style=color:red;background:yellow><strong>作用：将调用_S_chunk_alloc锁返回的640字节以32字节为一个等分，分成20等分，第一等分交给__result直接作为返回值，剩下的19个32字节会以链表的形式挂接在数组中下标为3的元素之下。</strong></span></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> <span class="title class_">_Obj</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">union</span> <span class="title class_">_Obj</span>* _M_free_list_link;</span><br><span class="line">    <span class="type">char</span> _M_client_data[<span class="number">1</span>];    <span class="comment">// The client sees this.</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>再回过头来看allocate函数，如果是第二次申请32字节空间，逻辑是怎样的</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">//假设申请32字节，__n = 32</span></span><br><span class="line">  <span class="comment">//_S_freelist_index(32) = 3</span></span><br><span class="line">  <span class="comment">//同样找到数组下标3位置</span></span><br><span class="line">_Obj** __my_free_list = _S_free_list + _S_freelist_index(__n);  </span><br><span class="line"> </span><br><span class="line">  <span class="comment">//这次_S_free_list的下标3位置存的不是空指针</span></span><br><span class="line">  <span class="comment">//而是还挂载着19个32字节</span></span><br><span class="line">_Obj* __RESTRICT __result = *__my_free_list;</span><br><span class="line"><span class="keyword">if</span> (__result == <span class="literal">nullptr</span>) </span><br><span class="line">  __ret = _S_refill(_S_round_up(__n));  <span class="comment">//跳转查看_S_round_up，再跳转查看_S_refill</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">  *__my_free_list = __result -&gt; _M_free_list_link;  <span class="comment">//让数组中下标3的元素（指针）指向再下一个内存块节点</span></span><br><span class="line">  __ret = __result;        <span class="comment">//又交出32字节</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>函数的调用关系图</strong></p>
<p><img src="/will-blog.github.io/./image-20240813182702055-1733127460324-148.png" alt="image-20240813182702055"></p>
<p>到现在自由链表大家应该有了一定的理解，那么内存池又是一个什么样的意义呢？</p>
<p>从名字上进行推理，线程池就是先创建一堆的线程备用，内存池应该也是先申请好一片空间备用。回到刚才的_S_chunk_alloc函数，这个函数是真正去分配空间的函数。刚才申请32字节空间时，根据源码逻辑是申请了1280个字节堆空间的，但只拿出了640个字节挂接在数组中下标为4的链表中。还有640个字节的空间干什么用？当然是备用的。</p>
<p>再试试看，根据源码分析，如果接下来又要申请64字节空间会怎样。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">__default_alloc_template</span> &#123;</span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="title">allocate</span><span class="params">(<span class="type">size_t</span> __n)</span> <span class="comment">//__n = 64</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="type">void</span>* __ret = <span class="number">0</span>;    </span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">//找到数组中下标为7的位置</span></span><br><span class="line">      _Obj** __my_free_list = _S_free_list + _S_freelist_index(__n);  </span><br><span class="line">        </span><br><span class="line">      _Obj* __RESTRICT __result = *__my_free_list; <span class="comment">//数组下标7位置的元素仍然是空指针   _S_free_list[7] = nullptr;</span></span><br><span class="line">      <span class="keyword">if</span> (__result == <span class="number">0</span>)</span><br><span class="line">          <span class="comment">//跳转_S_refill</span></span><br><span class="line">        __ret = _S_refill(_S_round_up(__n));  <span class="comment">//__ret = _S_refill(64);   </span></span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        *__my_free_list = __result -&gt; _M_free_list_link;</span><br><span class="line">        __ret = __result;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> __ret;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>* __default_alloc_template&lt;__threads, __inst&gt;::_S_refill(<span class="type">size_t</span> __n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> __nobjs = <span class="number">20</span>;</span><br><span class="line">    <span class="comment">//跳转先只执行完_S_chunk_alloc再看</span></span><br><span class="line">    <span class="type">char</span>* __chunk = _S_chunk_alloc(__n, __nobjs); <span class="comment">//char* __chunk = _S_chunk_alloc(64, 20)</span></span><br><span class="line">    _Obj* __STL_VOLATILE* __my_free_list;</span><br><span class="line">    _Obj* __result;</span><br><span class="line">    _Obj* __current_obj;</span><br><span class="line">    _Obj* __next_obj;</span><br><span class="line">    <span class="type">int</span> __i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1</span> == __nobjs) <span class="keyword">return</span>(__chunk);</span><br><span class="line">    </span><br><span class="line">    __my_free_list = _S_free_list + _S_freelist_index(__n);   <span class="comment">//定位数组下标为7的位置</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Build free list in chunk */</span></span><br><span class="line">      __result = (_Obj*)__chunk;  <span class="comment">//拿出64字节给__result</span></span><br><span class="line">      *__my_free_list = __next_obj = (_Obj*)(__chunk + __n); <span class="comment">//640字节首地址偏移64字节后强转，让数组下标7位置的元素指向第二个64字节</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//接下来的逻辑仍然是切割，将剩下的内存切割成了9个64字节</span></span><br><span class="line">      <span class="keyword">for</span> (__i = <span class="number">1</span>; ; __i++) &#123;</span><br><span class="line">        __current_obj = __next_obj;</span><br><span class="line">        __next_obj = (_Obj*)((<span class="type">char</span>*)__next_obj + __n);</span><br><span class="line">        <span class="keyword">if</span> (__nobjs - <span class="number">1</span> == __i) &#123;</span><br><span class="line">            __current_obj -&gt; _M_free_list_link = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            __current_obj -&gt; _M_free_list_link = __next_obj;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">return</span>(__result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> __threads, <span class="type">int</span> __inst&gt;</span><br><span class="line"><span class="type">char</span>* __default_alloc_template&lt;__threads, __inst&gt;::_S_start_free = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> __threads, <span class="type">int</span> __inst&gt;</span><br><span class="line"><span class="type">char</span>* __default_alloc_template&lt;__threads, __inst&gt;::_S_end_free = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> __threads, <span class="type">int</span> __inst&gt;</span><br><span class="line"><span class="type">size_t</span> __default_alloc_template&lt;__threads, __inst&gt;::_S_heap_size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> __threads, <span class="type">int</span> __inst&gt;</span><br><span class="line"><span class="type">char</span>* __default_alloc_template&lt;__threads, __inst&gt;::_S_chunk_alloc(<span class="type">size_t</span> __size,   <span class="comment">//__size = 64</span></span><br><span class="line">                                                            <span class="type">int</span>&amp; __nobjs)    <span class="comment">//__nobjs = 20   注意这里形参是引用，在函数中会通过形参改变实参</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span>* __result;</span><br><span class="line">    <span class="type">size_t</span> __total_bytes = __size * __nobjs; <span class="comment">//64 * 20 = 1280</span></span><br><span class="line">     <span class="comment">//第一次申请32时这个结果为0，所以走的是下面的第三个分支；</span></span><br><span class="line">    <span class="comment">//接着第一次申请64时这个结果已经是640了,所以应该走下面的第二个分支</span></span><br><span class="line">    <span class="type">size_t</span> __bytes_left = _S_end_free - _S_start_free; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (__bytes_left &gt;= __total_bytes) &#123;</span><br><span class="line">        __result = _S_start_free;</span><br><span class="line">        _S_start_free += __total_bytes;</span><br><span class="line">        <span class="keyword">return</span>(__result);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (__bytes_left &gt;= __size) &#123;</span><br><span class="line">        __nobjs = (<span class="type">int</span>)(__bytes_left/__size); <span class="comment">//640/64 = 10  注意这里__nobjs向外影响实参，改变为10</span></span><br><span class="line">        __total_bytes = __size * __nobjs; <span class="comment">//64 * 10 = 640</span></span><br><span class="line">        __result = _S_start_free;</span><br><span class="line">        _S_start_free += __total_bytes; <span class="comment">//_S_start_free经过了这样的偏移，实际上就跟_S_end_free指到一起了（代表着内存池里的内存贡献出来了）</span></span><br><span class="line">        <span class="keyword">return</span>(__result);   <span class="comment">//这里的逻辑就是把刚才剩余的640字节空间的首地址作为了返回值</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">size_t</span> __bytes_to_get = </span><br><span class="line">         <span class="number">2</span> * __total_bytes + _S_round_up(_S_heap_size &gt;&gt; <span class="number">4</span>);</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="./image-20250321210616655.png" alt="image-20250321210616655" style="zoom:80%;" />

<p>如果接着还要申请64字节（或者57-64范围内的大小），就再从数组中下标7位置对应的链表中再拿一个内存块出来，非常方便。</p>
<p>如果再要申请96个字节，操作方式跟第一次申请32字节一样，在数组下标11的位置下面挂载一些96字节的内存块。</p>
<p>假如接下来某一次要申请72字节，但是内存池和堆空间都没有连续的72字节了。想要使用相同的逻辑再申请空间不会成功，那么会往上借，也就是往数组下标9的位置去找，再没有就往下标10、下标11去找。下标11下面挂载着内存块，从中去除96字节的块，进行切割，获取72字节，剩24字节作为内存池中的内存。</p>
<img src="./image-20250321230025553.png" alt="image-20250321230025553" style="zoom:67%;" />

<img src="./image-20250321230047462.png" alt="image-20250321230047462" style="zoom:67%;" />





<p>目前为止，只是解决了allocate的问题，再来看看deallocate函数</p>
<p>如果是一级空间配置器，其背后就是调用free释放空间</p>
<p>如果是二级空间配置器，对应找到这个函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">deallocate</span><span class="params">(<span class="type">void</span>* __p, <span class="type">size_t</span> __n)</span>  <span class="comment">//__p就是某个内存节点的首地址，__n就是要回收的内存块大小</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (__n &gt; <span class="number">128</span>)</span><br><span class="line">     malloc_alloc::<span class="built_in">deallocate</span>(__p, __n);  <span class="comment">//底层还是free</span></span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="comment">//假设回收32字节，这一步就是定位到数组中下标3位置</span></span><br><span class="line">     _Obj**  __my_free_list = _S_free_list + _S_freelist_index(__n);</span><br><span class="line">     _Obj* __q = (_Obj*)__p;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//其实是把刚刚用完的32个字节又挂接到链表的头上去了，就是一个还原的操作逻辑</span></span><br><span class="line">     __q -&gt; _M_free_list_link = *__my_free_list;</span><br><span class="line">     *__my_free_list = __q;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>通过deallocate的逻辑我们也能理解一件事情 —— 为什么刚才需要72字节空间时要往上借到96字节，而不是往下借（比如更近的2 * 64，借两块）</p>
<p>因为这些链表中的内存块节点并不一定是连续的。虽然刚开始申请时是连续空间，但是用了一些内存块，又还了一些内存块后，链表连接的两块内存块就不一定连续了。</p>
<p><img src="/will-blog.github.io/./image-20250322000712966.png" alt="image-20250322000712966"></p>
<p>再看看构建对象的函数和销毁对象的函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">allocator</span> &#123;</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">construct</span><span class="params">(pointer __p, <span class="type">const</span> _Tp&amp; __val)</span> </span></span><br><span class="line"><span class="function"> </span>&#123; </span><br><span class="line">     <span class="comment">//定位new表达式，在指定的空间上构建对象</span></span><br><span class="line">     <span class="keyword">new</span>(__p) _Tp(__val); </span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">destroy</span><span class="params">(pointer __p)</span> </span></span><br><span class="line"><span class="function"> </span>&#123; </span><br><span class="line">     <span class="comment">//调用析构</span></span><br><span class="line">     __p-&gt;~_Tp();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure>



<p>总结函数的功能：</p>
<p><img src="/will-blog.github.io/./4image-20250322002150966.png" alt="image-20250322002150966"></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="https://willcool-cyber.github.io">will</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://willcool-cyber.github.io/2025/07/26/STL%E5%AE%B9%E5%99%A8%E5%BA%93%E8%A7%A3%E6%9E%90/">https://willcool-cyber.github.io/2025/07/26/STL%E5%AE%B9%E5%99%A8%E5%BA%93%E8%A7%A3%E6%9E%90/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/will-blog.github.io/tags/C/">C++</a></div><div class="post-share"><div class="social-share" data-image="/will-blog.github.io/img/butterfly-icon.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related full-width" href="/will-blog.github.io/2025/06/05/%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89%E4%B8%8E%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/" title="第二篇文章"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">Previous</div><div class="info-item-2">第二篇文章</div></div><div class="info-2"><div class="info-item-1">移动语义与智能指针移动语义为什么要用移动语义？ 让我们写一段String.cc 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include &lt;string.h&gt;#include &lt;iostream&gt;using std::cout;using std::endl;class String&#123;public:    String()    /* : _pstr(nullptr) */    : _pstr(new char[1]())    &#123;        cout &lt;&lt; &quot;String()&quot; &lt;&lt; endl;    &#125;   ...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/will-blog.github.io/2025/06/05/%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89%E4%B8%8E%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/" title="第二篇文章"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-06-05</div><div class="info-item-2">第二篇文章</div></div><div class="info-2"><div class="info-item-1">移动语义与智能指针移动语义为什么要用移动语义？ 让我们写一段String.cc 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include &lt;string.h&gt;#include &lt;iostream&gt;using std::cout;using std::endl;class String&#123;public:    String()    /* : _pstr(nullptr) */    : _pstr(new char[1]())    &#123;        cout &lt;&lt; &quot;String()&quot; &lt;&lt; endl;    &#125;   ...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/will-blog.github.io/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/will-blog.github.io/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">will</div><div class="author-info-description"></div><div class="site-data"><a href="/will-blog.github.io/archives/"><div class="headline">Articles</div><div class="length-num">4</div></a><a href="/will-blog.github.io/tags/"><div class="headline">Tags</div><div class="length-num">3</div></a><a href="/will-blog.github.io/categories/"><div class="headline">Categories</div><div class="length-num">6</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-STL%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93"><span class="toc-number">1.</span> <span class="toc-text">第一章 STL标准模板库</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#STL%E5%85%AD%E5%A4%A7%E7%BB%84%E4%BB%B6"><span class="toc-number">1.1.</span> <span class="toc-text">STL六大组件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8"><span class="toc-number">1.2.</span> <span class="toc-text">容器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%8F%E5%88%97%E5%BC%8F%E5%AE%B9%E5%99%A8"><span class="toc-number">1.2.1.</span> <span class="toc-text">序列式容器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">基本操作</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.2.1.1.1.</span> <span class="toc-text">初始化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%81%8D%E5%8E%86"><span class="toc-number">1.2.1.1.2.</span> <span class="toc-text">遍历</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9C%A8%E5%B0%BE%E9%83%A8%E8%BF%9B%E8%A1%8C%E6%8F%92%E5%85%A5%E4%B8%8E%E5%88%A0%E9%99%A4"><span class="toc-number">1.2.1.1.3.</span> <span class="toc-text">在尾部进行插入与删除</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9C%A8%E5%A4%B4%E9%83%A8%E8%BF%9B%E8%A1%8C%E6%8F%92%E5%85%A5%E4%B8%8E%E5%88%A0%E9%99%A4"><span class="toc-number">1.2.1.1.4.</span> <span class="toc-text">在头部进行插入与删除</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A8%A1%E5%9E%8B%E7%90%86%E8%A7%A3"><span class="toc-number">1.2.1.1.5.</span> <span class="toc-text">模型理解</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB"><span class="toc-number">1.2.1.1.6.</span> <span class="toc-text">源码阅读*</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#insert%E6%93%8D%E4%BD%9C%EF%BC%88%E9%87%8D%E8%A6%81%EF%BC%89"><span class="toc-number">1.2.1.1.7.</span> <span class="toc-text">insert操作（重要）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#erase%E6%93%8D%E4%BD%9C-%E9%87%8D%E8%A6%81"><span class="toc-number">1.2.1.1.8.</span> <span class="toc-text">erase操作(重要)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%83%E7%B4%A0%E7%9A%84%E6%B8%85%E7%A9%BA"><span class="toc-number">1.2.1.1.9.</span> <span class="toc-text">元素的清空</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.1.1.10.</span> <span class="toc-text">其他成员函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#emplace-back%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.1.1.11.</span> <span class="toc-text">emplace_back函数</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#list%E7%9A%84%E7%89%B9%E6%AE%8A%E6%93%8D%E4%BD%9C%EF%BC%88%E9%87%8D%E8%A6%81%EF%BC%89"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">list的特殊操作（重要）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#sort%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.1.2.1.</span> <span class="toc-text">sort函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#reverse%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.1.2.2.</span> <span class="toc-text">reverse函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#unique%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.1.2.3.</span> <span class="toc-text">unique函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#merge%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.1.2.4.</span> <span class="toc-text">merge函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#splice%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.1.2.5.</span> <span class="toc-text">splice函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E8%81%94%E5%BC%8F%E5%AE%B9%E5%99%A8"><span class="toc-number">1.2.2.</span> <span class="toc-text">关联式容器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#set%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">set的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9E%84%E9%80%A0"><span class="toc-number">1.2.2.1.1.</span> <span class="toc-text">构造</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%89%B9%E5%BE%81"><span class="toc-number">1.2.2.1.2.</span> <span class="toc-text">基本特征</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE"><span class="toc-number">1.2.2.1.3.</span> <span class="toc-text">查找</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#insert%E6%93%8D%E4%BD%9C"><span class="toc-number">1.2.2.1.4.</span> <span class="toc-text">insert操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#erase%E6%93%8D%E4%BD%9C"><span class="toc-number">1.2.2.1.5.</span> <span class="toc-text">erase操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%92%88%E5%AF%B9%E4%BA%8E%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%86%99%E6%B3%95%EF%BC%88%E9%87%8D%E8%A6%81%EF%BC%89"><span class="toc-number">1.2.2.1.6.</span> <span class="toc-text">针对于自定义类型的写法（重要）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#multiset%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">multiset的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%89%B9%E5%BE%81-1"><span class="toc-number">1.2.2.2.1.</span> <span class="toc-text">基本特征</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E5%8A%9F%E8%83%BD"><span class="toc-number">1.2.2.2.2.</span> <span class="toc-text">其他功能</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#bound%E7%B3%BB%E5%88%97%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.2.2.3.</span> <span class="toc-text">bound系列函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%92%88%E5%AF%B9%E4%BA%8E%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.2.2.2.4.</span> <span class="toc-text">针对于自定义类型</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#map%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">1.2.2.3.</span> <span class="toc-text">map的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%89%B9%E5%BE%81-2"><span class="toc-number">1.2.2.3.1.</span> <span class="toc-text">基本特征</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE-1"><span class="toc-number">1.2.2.3.2.</span> <span class="toc-text">查找</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#insert%E6%93%8D%E4%BD%9C-1"><span class="toc-number">1.2.2.3.3.</span> <span class="toc-text">insert操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#erase%E6%93%8D%E4%BD%9C-1"><span class="toc-number">1.2.2.3.4.</span> <span class="toc-text">erase操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%8B%E6%A0%87%E6%93%8D%E4%BD%9C%EF%BC%88%E9%87%8D%E8%A6%81%EF%BC%89"><span class="toc-number">1.2.2.3.5.</span> <span class="toc-text">下标操作（重要）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%92%88%E5%AF%B9%E4%BA%8E%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B-1"><span class="toc-number">1.2.2.3.6.</span> <span class="toc-text">针对于自定义类型</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#multimap%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">1.2.2.4.</span> <span class="toc-text">multimap的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%89%B9%E5%BE%81-3"><span class="toc-number">1.2.2.4.1.</span> <span class="toc-text">基本特征</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E6%93%8D%E4%BD%9C"><span class="toc-number">1.2.2.4.2.</span> <span class="toc-text">其他操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%8D%E6%94%AF%E6%8C%81%E4%B8%8B%E6%A0%87"><span class="toc-number">1.2.2.4.3.</span> <span class="toc-text">不支持下标</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%92%88%E5%AF%B9%E4%BA%8E%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B-2"><span class="toc-number">1.2.2.4.4.</span> <span class="toc-text">针对于自定义类型</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.2.2.5.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A0%E5%BA%8F%E5%85%B3%E8%81%94%E5%BC%8F%E5%AE%B9%E5%99%A8"><span class="toc-number">1.2.3.</span> <span class="toc-text">无序关联式容器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E7%9B%B8%E5%85%B3%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">哈希相关的概念</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81"><span class="toc-number">1.2.3.1.1.</span> <span class="toc-text">如何解决哈希冲突</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#unordered-set%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">unordered_set的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%89%B9%E5%BE%81-4"><span class="toc-number">1.2.3.2.1.</span> <span class="toc-text">基本特征</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E6%93%8D%E4%BD%9C-1"><span class="toc-number">1.2.3.2.2.</span> <span class="toc-text">其他操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%92%88%E5%AF%B9%E4%BA%8E%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%EF%BC%88%E9%87%8D%E8%A6%81%EF%BC%89"><span class="toc-number">1.2.3.2.3.</span> <span class="toc-text">针对于自定义类型（重要）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#unordered-multiset%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">1.2.3.3.</span> <span class="toc-text">unordered_multiset的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%89%B9%E5%BE%81-5"><span class="toc-number">1.2.3.3.1.</span> <span class="toc-text">基本特征</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E6%93%8D%E4%BD%9C-2"><span class="toc-number">1.2.3.3.2.</span> <span class="toc-text">其他操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%92%88%E5%AF%B9%E4%BA%8E%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B-3"><span class="toc-number">1.2.3.3.3.</span> <span class="toc-text">针对于自定义类型</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#unordered-map%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">1.2.3.4.</span> <span class="toc-text">unordered_map的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%89%B9%E5%BE%81-6"><span class="toc-number">1.2.3.4.1.</span> <span class="toc-text">基本特征</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E6%93%8D%E4%BD%9C-3"><span class="toc-number">1.2.3.4.2.</span> <span class="toc-text">其他操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%94%AF%E6%8C%81%E4%B8%8B%E6%A0%87%EF%BC%88-%E9%87%8D%E8%A6%81-%EF%BC%89"><span class="toc-number">1.2.3.4.3.</span> <span class="toc-text">支持下标（&#x3D;&#x3D;重要&#x3D;&#x3D;）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#unordered-multimap%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">1.2.3.5.</span> <span class="toc-text">unordered_multimap的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%89%B9%E5%BE%81-7"><span class="toc-number">1.2.3.5.1.</span> <span class="toc-text">基本特征</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E6%93%8D%E4%BD%9C-4"><span class="toc-number">1.2.3.5.2.</span> <span class="toc-text">其他操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%8D%E6%94%AF%E6%8C%81%E4%B8%8B%E6%A0%87-1"><span class="toc-number">1.2.3.5.3.</span> <span class="toc-text">不支持下标</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-number">1.2.3.6.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E7%9A%84%E9%80%89%E6%8B%A9%EF%BC%88%E9%87%8D%E8%A6%81%EF%BC%89"><span class="toc-number">1.2.4.</span> <span class="toc-text">容器的选择（重要）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E9%80%82%E9%85%8D%E5%99%A8"><span class="toc-number">1.2.5.</span> <span class="toc-text">容器适配器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97"><span class="toc-number">1.2.5.1.</span> <span class="toc-text">优先级队列</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">1.2.5.1.1.</span> <span class="toc-text">基本使用方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%87%BD%E6%95%B0%E6%80%BB%E7%BB%93"><span class="toc-number">1.2.5.1.2.</span> <span class="toc-text">使用函数总结</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%92%88%E5%AF%B9%E4%BA%8E%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B-4"><span class="toc-number">1.2.5.1.3.</span> <span class="toc-text">针对于自定义类型</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">1.3.</span> <span class="toc-text">迭代器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5"><span class="toc-number">1.3.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.3.2.</span> <span class="toc-text">迭代器的类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">1.3.3.</span> <span class="toc-text">流迭代器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E6%B5%81%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">输出流迭代器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E6%B5%81%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">1.3.3.2.</span> <span class="toc-text">输入流迭代器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E9%80%82%E9%85%8D%E5%99%A8"><span class="toc-number">1.3.4.</span> <span class="toc-text">迭代器适配器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E7%BB%84%E6%8F%92%E5%85%A5%E8%BF%AD%E4%BB%A3%E5%99%A8%E9%80%82%E9%85%8D%E5%99%A8%EF%BC%88%E6%8E%8C%E6%8F%A1%EF%BC%89"><span class="toc-number">1.3.4.1.</span> <span class="toc-text">三组插入迭代器适配器（掌握）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8D%E5%90%91%E8%BF%AD%E4%BB%A3%E5%99%A8%E9%80%82%E9%85%8D%E5%99%A8"><span class="toc-number">1.3.4.2.</span> <span class="toc-text">反向迭代器适配器</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95"><span class="toc-number">1.4.</span> <span class="toc-text">算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E7%82%B9"><span class="toc-number">1.4.1.</span> <span class="toc-text">特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E7%B1%BB"><span class="toc-number">1.4.2.</span> <span class="toc-text">分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#for-each%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">1.4.3.</span> <span class="toc-text">for_each函数的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E9%87%8D%E8%A6%81"><span class="toc-number">1.4.4.</span> <span class="toc-text">lambda表达式(重要)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95%E7%BB%93%E6%9E%84"><span class="toc-number">1.4.4.1.</span> <span class="toc-text">语法结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E6%8D%95%E8%8E%B7%E4%B8%8E%E5%80%BC%E6%8D%95%E8%8E%B7%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.4.4.2.</span> <span class="toc-text">引用捕获与值捕获的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8F%AF%E4%BB%A5%E8%A2%AB%E6%8E%A5%E6%94%B6"><span class="toc-number">1.4.4.3.</span> <span class="toc-text">lambda表达式可以被接收</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.4.4.4.</span> <span class="toc-text">lambda表达式的返回类型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#remove-if%E5%87%BD%E6%95%B0"><span class="toc-number">1.4.5.</span> <span class="toc-text">remove_if函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-number">1.4.5.1.</span> <span class="toc-text">基本使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BA%90%E7%A0%81"><span class="toc-number">1.4.5.2.</span> <span class="toc-text">源码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E9%80%82%E9%85%8D%E5%99%A8"><span class="toc-number">1.4.6.</span> <span class="toc-text">算法适配器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%BB%91%E5%AE%9A%E5%99%A8bind1st%E3%80%81bind2nd"><span class="toc-number">1.4.6.1.</span> <span class="toc-text">函数绑定器bind1st、bind2nd</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#bind%EF%BC%88%E9%9D%9E%E5%B8%B8%E9%87%8D%E8%A6%81%EF%BC%89"><span class="toc-number">1.4.6.2.</span> <span class="toc-text">bind（非常重要）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8-1"><span class="toc-number">1.4.6.2.1.</span> <span class="toc-text">基本使用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E6%8A%98%E5%8F%A0"><span class="toc-number">1.4.6.2.2.</span> <span class="toc-text">引用折叠</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88"><span class="toc-number">1.4.6.2.3.</span> <span class="toc-text">函数指针</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8D%A0%E4%BD%8D%E7%AC%A6"><span class="toc-number">1.4.6.2.4.</span> <span class="toc-text">占位符</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#function%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">1.4.6.3.</span> <span class="toc-text">function的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%91%E5%AE%9A%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E7%9A%84%E4%BC%A0%E5%8F%82"><span class="toc-number">1.4.6.3.1.</span> <span class="toc-text">绑定成员函数的传参</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#function%E8%A1%A8%E7%A4%BAlambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">1.4.6.3.2.</span> <span class="toc-text">function表示lambda表达式返回值</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#function%E4%BD%BF%E7%94%A8%E7%9A%84%E8%AF%AF%E5%8C%BA"><span class="toc-number">1.4.6.3.3.</span> <span class="toc-text">function使用的误区</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#bind%E4%B8%8Efunction%E7%9A%84%E7%BB%93%E5%90%88%E4%BD%BF%E7%94%A8%EF%BC%88%E9%87%8D%E8%A6%81%EF%BC%89"><span class="toc-number">1.4.6.4.</span> <span class="toc-text">bind与function的结合使用（重要）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mem-fn%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E9%80%82%E9%85%8D%E5%99%A8"><span class="toc-number">1.4.7.</span> <span class="toc-text">mem_fn成员函数适配器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%82%E9%85%8D%E5%99%A8"><span class="toc-number">1.5.</span> <span class="toc-text">适配器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.6.</span> <span class="toc-text">函数对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8%EF%BC%88%E9%87%8D%E9%9A%BE%E7%82%B9%EF%BC%89"><span class="toc-number">1.7.</span> <span class="toc-text">空间配置器（重难点）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8"><span class="toc-number">1.7.1.</span> <span class="toc-text">函数使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%90%86"><span class="toc-number">1.7.2.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BA%90%E7%A0%81-1"><span class="toc-number">1.7.3.</span> <span class="toc-text">源码</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Posts</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/will-blog.github.io/2025/07/26/STL%E5%AE%B9%E5%99%A8%E5%BA%93%E8%A7%A3%E6%9E%90/" title="第三篇文章">第三篇文章</a><time datetime="2025-07-26T06:22:45.000Z" title="Created 2025-07-26 14:22:45">2025-07-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/will-blog.github.io/2025/06/05/%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89%E4%B8%8E%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/" title="第二篇文章">第二篇文章</a><time datetime="2025-06-05T10:30:00.000Z" title="Created 2025-06-05 18:30:00">2025-06-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/will-blog.github.io/2025/06/03/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" title="第一篇文章">第一篇文章</a><time datetime="2025-06-03T12:30:00.000Z" title="Created 2025-06-03 20:30:00">2025-06-03</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/will-blog.github.io/2025/06/03/hello-world/" title="Hello World">Hello World</a><time datetime="2025-06-03T11:29:51.738Z" title="Created 2025-06-03 19:29:51">2025-06-03</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By will</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/will-blog.github.io/js/utils.js"></script><script src="/will-blog.github.io/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>